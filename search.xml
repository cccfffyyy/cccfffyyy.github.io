<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python学习-Day2]]></title>
    <url>%2F2019%2F05%2F28%2Fpython-2019.05.28%2F</url>
    <content type="text"><![CDATA[条件判断 练习>&gt;&gt;age = 3>&gt;&gt;if age &gt;= 18:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;print(‘Adult’)>&gt;&gt;elif age&gt;6:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;print(‘Teenager’)>&gt;&gt;else:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;print(‘Kid’)Kid >&gt;&gt;s = input(‘birth is : ‘)>&gt;&gt;birth = int(s) &nbsp;&nbsp;#输入为字符串，需要转换格式>&gt;&gt;if birth &lt; 2000:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;print(‘00前’)>&gt;&gt;else:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;print(‘00后’)birth is : 199500前 >&gt;&gt;print(‘格式 身高：1.75m 体重：80.5kg’)>&gt;&gt;a = input(‘Your height : ‘)>&gt;&gt;b = input(‘Your weight : ‘)>&gt;&gt;height = float(a)>&gt;&gt;weight = float(b)>&gt;&gt;bmi=weight/(height*height)>&gt;&gt;if bmi&gt;32:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;print(‘Your BMI is : ‘,bmi,’严重肥胖’)>&gt;&gt;elif bmi&gt;28:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;print(‘Your BMI is : ‘,bmi,’肥胖’)>&gt;&gt;elif bmi&gt;25:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;print(‘Your BMI is : ‘,bmi,’过重’)>&gt;&gt;elif bmi&gt;18.5:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;print(‘Your BMI is : ‘,bmi,’正常’)>&gt;&gt;else:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;print(‘Your BMI is : ‘,bmi,’过轻’)格式 身高：1.75m 体重：80.5kgYour height : 1.75Your weight : 68Your BMI is : 22.20408163265306 正常 循环for…in 练习>&gt;&gt;names=[‘A’,’B’,’C’,’D’]>&gt;&gt;for name in names:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;print(name)ABCD >&gt;&gt;sum=0>&gt;&gt;for x in range(101): #整数序列函数>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;sum=sum+x>&gt;&gt;print(sum)5050 >&gt;&gt;L = [‘Bart’, ‘Lisa’, ‘Adam’]>&gt;&gt;for x in L:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;print(x)BartLisaAdam >&gt;&gt;n = 1>&gt;&gt;while n &lt;=100:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;if n&gt;5:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break #提前结束循环>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;print(n)>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;n=n+1>&gt;&gt;print(‘end’)12345end >&gt;&gt;n = 0>&gt;&gt;while n &lt; 10:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;n=n+1>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;if n%2 == 0:>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue #跳过这次循环，直接进行到下次>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;print(n)13579 dict内置字典：dict，使用键-值（key-value）存储，具有极快的查找速度和list相比，dict查找的插入速度极快，但是占用大量内存，内存浪费多 练习>&gt;&gt;d={‘MARY’:90,>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;’JOHN’:80,>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;’ALICE’:95}>&gt;&gt;print(d)>&gt;&gt;d[‘MARY’]=80>&gt;&gt;print(d[‘MARY’])>&gt;&gt;d.pop(‘ALICE’)>&gt;&gt;print(d)>&gt;&gt;print(d.get(‘ALICE’,-1)){‘MARY’: 90, ‘JOHN’: 80, ‘ALICE’: 95}80{‘MARY’: 80, ‘JOHN’: 80}-1 setset也是一组key的集合，但是不存储value，set中无重复的key。创建一个set，需要提供一个list作为输入集合。 练习>&gt;&gt;s1=set([1,2,3])>&gt;&gt;print(s)>&gt;&gt;s1.add(4)>&gt;&gt;print(s)>&gt;&gt;s1.remove(4)>&gt;&gt;print(s)>&gt;&gt;s2=set([3,4,5]>&gt;&gt;print(s1&amp;s2)>&gt;&gt;print(s1|s2){1, 2, 3}{1, 2, 3}{1, 2, 3}{3}{1, 2, 3, 4, 5} 小结：条件判断格式 if:… elif:… else:循环 第一种 while:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种 for…in:循环控制：break，continue 元素可变：list，dict，set元素不可变：tuple]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day1]]></title>
    <url>%2F2019%2F05%2F27%2Fpython-2019.05.27%2F</url>
    <content type="text"><![CDATA[首先进行环境安装（Mac）1.python安装 brew install pythonpython -V &nbsp; //版本查看 2.jupyter安装 pip3 install jupyterjupyter notebook &nbsp; //启动服务 环境配置好后，小白开始学习python啦～[python学习资料链接]（https://www.liaoxuefeng.com/wiki/1016959663602400） python基础注释用#标记，转义字符用\标记等号=是赋值语句，可以把任意数据类型赋值给变量，同一变量可以被反复赋值，且可以是不同类型的变量。动态语言。 格式化字符串：% %s 表示用字符串替换； %d 表示用整数替换 %f 表示用浮点数替换 练习>&gt; print(‘hello,%s~ %d day fighting!’%(‘cuify’,1))hello,cuify~ 1 day fighting! list有序列表，可以随时添加和删除其中的元素 练习>&gt;&gt;classmates=[‘TOM’,’JACK’,’MARY’]>&gt;&gt;classmates.append(‘ALICE’) #添加元素>&gt;&gt;classmates.insert(1,’JOHN’) #插入元素>&gt;&gt;print(classmates)>&gt;&gt;classmates.pop(1) &nbsp;#pop(i) i是索引位置，没写的话会删除最后一个元素>&gt;&gt;print(classmates)>&gt;&gt;classmates[1]=’IVY’>&gt;&gt;print(classmates)[‘TOM’, ‘JOHN’, ‘JACK’, ‘MARY’, ‘ALICE’][‘TOM’, ‘JACK’, ‘MARY’, ‘ALICE’][‘TOM’, ‘IVY’, ‘MARY’, ‘ALICE’] >&gt;&gt;s=[‘apple’,’banana’,’peach’]>&gt;&gt;p=[‘watermelon’,s,’grape’]>&gt;&gt;print(p)[‘watermelon’, [‘apple’, ‘banana’, ‘peach’], ‘grape’] tuple有序列表，一旦初始化就不能修改。tuple的元素不变指的是tuple的每个元素，指向永不变。 练习>&gt;&gt;classmates=(‘TOM’,’JACK’,’MARY’)>&gt;&gt;print(classmates)(‘TOM’, ‘JACK’, ‘MARY’) >&gt;&gt;s=(‘a’,’b’,[‘X’,’Y’],’c’)>&gt;&gt;print(s)>&gt;&gt;s[2][0]= ‘D’ #tuple里面嵌套list，可以更改list中的元素。>&gt;&gt;print(s)(‘a’, ‘b’, [‘X’, ‘Y’], ‘c’)(‘a’, ‘b’, [‘D’, ‘Y’], ‘c’)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统工程师软考知识点整理]]></title>
    <url>%2F2019%2F05%2F23%2F%E8%BD%AF%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[数据库系统工程师-软考知识点整理 💯1.音频数字化过程中采样频率应为声音最高频率2倍 2.编译过程：词法分析阶段&gt;语法分析阶段&gt;语义分析阶段&gt;中间代码生成&gt;目标代码生成 3.面向对象方法中的多态：不同类的对象对同一消息做出不同响应。三个条件为有继承关系、子类重写父类方法、父类引用指向子类对象 4.外模式/模式：数据与程序的逻辑独立性，简称数据的逻辑独立性 模式/内模式：数据与程序的物理独立性，简称数据的物理独立性 5.数据模型三要素：数据结构、数据操纵、完整性约束 6.候选码只出现在左边 7.无损连接性判断：存在R1∩R2-&gt;R1-R2或R1∩R2-&gt;R2-R1被F逻辑蕴含的情况，则具有无损连接性无损联接分解是将一个关系模式分解成若干个关系模式后，通过自然联接和投影等运算仍能还原到原来的关系模式，则称这种分解为无损联接分解。 8.满足函数依赖的条件：分解后所有的关系模式加起来和原先的关系模式中的函数依赖是一样的 9.数据库概念结构设计阶段：抽象&gt;设计局部视图&gt;合并取消冲突&gt;修改重构消除冗余 10.路由策略：为了改变网络流量所经过的途径而修改路由信息的技术 11.网络层次与主要设备对应关系： 网络层-路由器，数据链路层-网桥、交换机，传输层和会话层-软件功能 12.I/O设备管理软件一般分4层：中断处理程序、设备驱动程序、与设备无关的系统软件和用户级软件 13.假如关系R和S的元数分别为r和s，那么他们的笛卡儿积就是r+s的元组组合，而若R有m个元组，S有n个元组，则R×S应有m*n个元组 14.脏读：读取未提交数据&emsp;&nbsp;不可重复读：前后多次读取，读取内容不一致&emsp;&nbsp;幻影读：前后多次读取，读取数据总量不一致 15.部分函数依赖：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。举个例子：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。 完全函数依赖：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。举个例子：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB. 传递函数依赖：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。举个例子：通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么成C传递依赖于A 16.三种范式1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项。2、第二范式（2NF）：满足第一范式，然后消除部分依赖。3、第三范式（3NF）： 满足第二范式，消除传递依赖。 17.触发器的定义：某个条件成立的时候，触发器里定义的语句就会被自动的执行。触发器不需要人为的去调用，也不能调用。(1).语句级触发器：可以在某些语句执行前或执行后被触发(2).行级触发器：在定义了触发的表中的行数据改变时就会被触发一次 18.E-R图1.三要素：实体（矩形）、属性（椭圆形）、关系（菱形）2.作为主键的属性在文字下面加下划线3.多值属性 双线椭圆表示；派生属性 虚线椭圆表示；可选属性 椭圆的文字后用(o)表示 19.三类加密算法三类：(1).对称加密：加密和解密使用相同密钥的加密算法。DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES (2).非对称加密：加密和解密使用不同密钥的加密算法，也叫公私钥加密。RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用） (3).Hash算法：Hash算法常用在不可还原的密码存储、信息完整性校验等。MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1 非对称加密算法运行速度慢，可以实现签名；对称加密算法，建议在需要加密大量数据的时候使用，提高加解密速度； 在实际的操作过程中，通常采用的方式是：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。 20.PV操作与信号量的处理有关，P表示通过，V表示释放。用一个信号量与一个消息联系起来，当信号量的值为0时，表示期望的消息尚未产生；当信号量的值非0时，表示期望的消息已经存在。用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。 21.2PL 两段锁协议定义：所有的读写操作之前均需要加锁，解锁操作后不允许出现加锁操作。S锁：加S锁后其他事务可读不可写，直至加锁事务结束；X锁：加X锁后其他事务均不可读或者写，直至事务结束；事务执行分两个阶段：1是获得封锁阶段，2是释放封锁阶段，2PL可能会产生死锁；2PL可以防止丢失修改、读脏数据等；是事务可串行化的必要条件，但不是充分条件； 22.可串行性：当一组事务交叉执行的结果和串行执行的结果一致时，这组事务具有可串行性 23.一级锁：所有写操作前加X锁，事务结束释放，可以防止丢失修改二级锁：所有写操作前加X锁，事务结束释放；读操作前加S锁，操作结束释放，可以防止丢失修改和读脏数据三级锁：所有写操作前加X锁，事务结束释放；读操作前加S锁，事务结束释放，可以防止丢失修改和读脏数据、不可重复读。]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.05.23 ☀️]]></title>
    <url>%2F2019%2F05%2F23%2F2019.05.23%2F</url>
    <content type="text"><![CDATA[离考试还有两天，学习进度达到20%记录，😢]]></content>
      <tags>
        <tag>零零碎碎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.05.16 ☀️]]></title>
    <url>%2F2019%2F05%2F16%2F2019.05.16%2F</url>
    <content type="text"><![CDATA[一些以前写的想法2018.10.25梦会反映现实中捕捉不到的潜意识，负面的、希望的，然而使我略微欣慰的,是我在现实中隐隐意识到了，或许我在主动面对这样自己了。 2018.11.06突然就会很想感谢生命中的贵人，感谢他们在我人生中每一个微不足道的节骨眼助了力。 2018.11.12生日周的第一天变得很亢奋，一下不能理解原来的负面情绪都是从哪来的了。 2019.2.15今天开始准备数据库系统工程师的考试，希望能坚持下去，要把大学的专业课重新看一遍，脑壳痛。脑子饱了，肚子瘪了。]]></content>
      <tags>
        <tag>零零碎碎</tag>
      </tags>
  </entry>
</search>
