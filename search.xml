<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F06%2F04%2Fpython-20190604%2F</url>
    <content type="text"><![CDATA[title: python学习-Day7date: 2019-06-04 09:47:12copyright: true tags: python模块（Module）Python中一个.py文件就称为一个模块。模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。每一个包目录下面都会有一个init.py的文件，这个文件必须存在。Python所有内置函数作用域模块内部使用，通过前缀_实现,最好不要直接引用。（private） 12345678#!/usr/bin/env/ python3#-*- coding:utf-8 -*-def _private(): return '非公开函数'def public(): print('调用非公开函数：') return _private()print(public()) 调用非公开函数： 非公开函数 面向对象编程类和实例类名通常是大写开头的单词，class后面接类名，紧接着是(object)，表示该类是从哪个类继承下来的，通常没有合适的类就用object类，这是所有类最终都会继承的类。特殊方法“__init__”前后分别有两个下划线，第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。 1234567891011121314151617181920212223class Student(object): def __init__(self,name,score,age): self.name = name self.score = score self.__age = age def printScore(self): print('%s :%s'%(self.name,self.score)) def getGrade(self): if self.score&gt;=90: return 'A' elif self.score&gt;=80: return 'B' elif self.score&gt;=60: return 'C' else: return 'D' def getAge(self): return self.__agelisa = Student('Lisa',98,18)lisa.printScore()bart = Student('Bart',80,20)print(bart.getGrade())lisa.getAge() #外部不能直接访问lisa.__age属性了 Lisa :98 B 18 PS:今天有点忙了，就看了一点，😁]]></content>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day6]]></title>
    <url>%2F2019%2F06%2F03%2Fpython-20190603%2F</url>
    <content type="text"><![CDATA[高阶函数过滤（filter）filter()函数用于过滤序列，依次作用于每个元素，根据返回值是True或False决定保留还是丢弃该元素。filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。 12345678910111213141516171819202122#用filter求素数def _odd_iter(): #构建一个生成器，无限奇数序列 n = 1 while True: n = n + 2 yield ndef _not_div(n): #定义一个筛选函数 return lambda x : x % n &gt; 0def primes(): #定义一个生成器，不断返回下一个素数 yield 2 it = _odd_iter() #初始序列 while True: n = next(it) yield n it = filter(_not_div(n),it)l=[]for n in primes(): if n &lt; 100: l.append(n) else: breakprint(l) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] 12345678def is_palindrome(n): return n==int(str(n)[::-1]) #判断倒序是否等于正序output = filter(is_palindrome, range(1, 200))print('1~200:', list(output))if list(filter(is_palindrome, range(1, 200))) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]: print('测试成功!')else: print('测试失败!') 1~200: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191] 测试成功! 排序（sorted）内置的sorted函数可以对list进行排序，还可以接受一个key函数来实现自定义的顺序，key指定的函数作用于list的每一个元素上，并根据key函数返回的结果进行排序 123#sortedprint(sorted([3,-234,5,6,23,17],key=abs)) #引用绝对值函数print(sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower,reverse=True)) #reverse 实现反向排序 [3, 5, 6, 17, 23, -234] [&#39;Zoo&#39;, &#39;Credit&#39;, &#39;bob&#39;, &#39;about&#39;] 123456789#按名字排序def by_name(t): return t[0]#按成绩从高到低排序def by_score(t): return -t[1]L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]print(sorted(L,key=by_name))print(sorted(L,key=by_score)) [(&#39;Adam&#39;, 92), (&#39;Bart&#39;, 66), (&#39;Bob&#39;, 75), (&#39;Lisa&#39;, 88)] [(&#39;Adam&#39;, 92), (&#39;Lisa&#39;, 88), (&#39;Bob&#39;, 75), (&#39;Bart&#39;, 66)] 返回函数一个函数可以返回一个计算结果，也可以返回一个函数。返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。 123456789101112def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count()print(f1())print(f2())print(f3()) 9 9 9 12345678910#利用闭包返回一个计数器函数，每次调用它返回递增整数def createCounter(): a=0 def counter(): nonlocal a #使用外层变量 a +=1 return a return countercounterA = createCounter()print(counterA(), counterA(), counterA(), counterA(), counterA()) 1 2 3 4 5 匿名函数关键字lambda表示匿名函数，只能有一个表达式 1234A=list(map(lambda x : x * x,[1,2,3,4,5]))L = list(filter(lambda n : n % 2 == 1, range(1, 20)))print(A)print(L) [1, 4, 9, 16, 25] [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] 装饰器（Decorator）没看懂学习资料里这块的内容🙍，网上查了下，写一点自己对装饰器的理解～装饰器就是可以给任意的函数加点东西，用新的功能包装一下 12345678910#简单版import functoolsdef decorator(fn): #被装饰的函数作为参数传入 print('我是装饰！！！装饰的函数是：%s'%fn.__name__) #作为装饰 return fn@decoratordef fn(): print('这里需要装饰一下。。')fn() 我是装饰！！！装饰的函数是：fn 这里需要装饰一下。。 12345678910111213141516171819202122232425262728#练习，请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间import functools,datetime,timedef log(text): def decorator(fn): @functools.wraps(fn) def wrapper(*args,**kw): #可以接受任意参数的调用,该函数作为装饰 print('执行的函数：%s 执行的时间 ：%s %s'%(fn.__name__,datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),text)) return fn(*args,**kw) return wrapper return decorator@log('测试带参数1～')def fast(x, y): time.sleep(0.0012) return x + y;@log('测试带参数2~')def slow(x, y, z): time.sleep(0.1234) return x * y * z;f = fast(11, 22)print(f)s = slow(11, 22, 33)print(s)if f != 33: print('测试失败!')elif s != 7986: print('测试失败!') 执行的函数：fast 执行的时间 ：2019-06-04 09:36:24 测试带参数1～ 33 执行的函数：slow 执行的时间 ：2019-06-04 09:36:24 测试带参数2~ 7986 偏函数（partial）函数：functools.partial()当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单 12345#偏函数int2=functools.partial(int,base=8) #字符8进制转换print(int2('12345'))max2=functools.partial(max,10) #会把10加入比较print(max2(1,2,3,4)) 5349 10]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day5]]></title>
    <url>%2F2019%2F05%2F31%2Fpython-20190531%2F</url>
    <content type="text"><![CDATA[列表生成式（List Comprehensions）列表生成式时，把要生成的元素放到前面，后面跟for循环，就可以把list创建出来。 123456print([x*x for x in range(1,11) if x%2 == 0]) #可以加if判断print([m+n for m in 'ABC' for n in 'DEF']) #两层循环d = &#123;'a':'A','b':'B','c':'C'&#125;print([k+'='+v for k,v in d.items()]) #用两个变量生成listL=['MARK','SANDY','SOPHIA']print([s.lower() for s in L]) [4, 16, 36, 64, 100] [&#39;AD&#39;, &#39;AE&#39;, &#39;AF&#39;, &#39;BD&#39;, &#39;BE&#39;, &#39;BF&#39;, &#39;CD&#39;, &#39;CE&#39;, &#39;CF&#39;] [&#39;a=A&#39;, &#39;b=B&#39;, &#39;c=C&#39;] [&#39;mark&#39;, &#39;sandy&#39;, &#39;sophia&#39;] 123#实现列表所有字符串小写L = ['Hello', 'World', 18, 'Apple', None][s.lower() for s in L if isinstance(s,str)] [&#39;hello&#39;, &#39;world&#39;, &#39;apple&#39;] 生成器（generator） 把一个列表生成式的[]改成()，就创建了一个generator。 如果一个函数中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。调用函数就是创建了一个生成器（generator）。yield相当于 return 返回一个值，并且记住这个返回的位置，下次迭代时，代码从yield的下一条语句开始执行 。 抛出StopIteration错误表示无法继续返回下一个值了 12345#生成器g=(x*x for x in range(1,11)) #generater和list的区别是最外层的括号。g是(),list是[]print(next(g))print(next(g))#每次调用next(),是下一个元素的值print([i for i in g]) #利用循环打印所有g的值 1 4 [9, 16, 25, 36, 49, 64, 81, 100] 12345678910def fib(max): n=0 a=0 b=1 while n&lt;max: yield b #定义中包含yield关键字，该函数就是generator a,b=b,a+b n+=1 return 'done'print([i for i in fib(4)]) [1, 1, 2, 3] 1234567891011def odd(): print('step 1') yield 1 print('step 2') yield 2 print('step 3') yield 5o=odd()print(next(o))print(next(o))print(next(o)) step 1 1 step 2 2 step 3 5 1234567891011121314#杨辉三角def triangles(): p = [1] while True: yield p p =[1]+[p[x]+p[x+1] for x in range(len(p)-1)]+[1] #这行看了好久才看懂。。p=[1,3,3,1] x=0,1,2n = 0results = []for t in triangles(): print(t) results.append(t) n = n + 1 if n == 6: break [1] [1, 1] [1, 2, 1] [1, 3, 3, 1] [1, 4, 6, 4, 1] [1, 5, 10, 10, 5, 1] 迭代器（Iterator）可以判断一个对象是否为可迭代对象：isinstance([],Iterable) 12from collections import Iterableisinstance([],Iterable) True 凡是可以作用于for循环的对象都是Iterable类型； 可作用于next()函数的对象都是Iterator类型 集合数据类型如list、dict、str等都是Iterable，不是Iterator，可以通过iter()函数获得一个Iterator对象 函数式编程（Functional Programing）特点：允许把函数本身作为一个参数传入另一个参数，还允许返回一个函数。抽象度高，贴近计算，执行效率低 。Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。 高阶函数函数本身可以赋值给变量，变量可以指向函数。 一个函数可以接受另一个函数做参数，那么这个函数就叫高阶函数。 123456#高阶函数f=absf(-10)def add(x,y,f): return f(x)+f(y)print(add(-1,-6,abs)) 7 map/reducemap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 12345#mapdef f(x): return x*xr=map(f,[1,2,3,4,5])list(r) [1, 4, 9, 16, 25] reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。 12345#reducefrom functools import reduce def add(x,y): return x+yreduce(add,[1,2,3,4,5]) 15 123456789from functools import reducedef str2int(s): def fn(x,y): #输出一个整数 return 10*x+y def char2num(s): #数值与字符对应转换 digits=&#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125; return digits[s] return reduce(fn,map(char2num,s))str2int('1234') 1234 练习 12345678910111213141516171819202122232425#利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']def normalize(l): return l[0].upper()+l[1:].lower()L1 = ['adam', 'LISA', 'barT']L2 = list(map(normalize, L1))print(L2)#请编写一个prod()函数，可以接受一个list并利用reduce()求积def prod(l): def mul(x,y): return x*y return reduce(mul,l)print('3 * 5 * 7 * 9 =', prod([3, 5, 7, 9]))#利用map和reduce编写一个str2float函数，把字符串'123.456'转换成浮点数123.456from functools import reducedef str2float(s): s1,s2 = s.split('.') def fn(x,y): return 10*x+y def char2num(s): digits = &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125; return digits[s] return reduce(fn,map(char2num,s1))+reduce(fn,map(char2num,s2))/(10*len(s2))print(str2float('1234.45')) [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;] 3 * 5 * 7 * 9 = 945 1236.25]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day4]]></title>
    <url>%2F2019%2F05%2F30%2Fpython-20190530%2F</url>
    <content type="text"><![CDATA[高级特性代码越少越好！越简单越好！ 切片（Slice）根据索引取list或tuple的部分元素list、tuple、字符串都可以使用切片 12345678910#切片L = ['A','B','C','D','E']print(L[0:3]) #从索引0开始，到索引3但不包括索引3M = list(range(20))print(M)print(M[-4:-1]) #倒数第一个元素的索引是-1print(M[:10:2]) #前10个数，每两个取一个print(M[::5]) #所有数，每五个取一个print(len(M))print(M[len(M)-1]) [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] [16, 17, 18] [0, 2, 4, 6, 8] [0, 5, 10, 15] 20 19 1234567891011121314151617181920212223242526272829303132333435363738394041424344#实现一个trim()函数，去除字符串首尾的空格def trim(string): if string[0] == ' ' and string[len(string)-1] == ' ': return string[1:len(string)-1] elif string[0] == ' ': return string[1:] elif string[len(string)-1] == ' ': return string[0:len(string)-1] else: return stringprint(trim(' ABCD '))print(trim(' ABCD'))print(trim('ABCD '))#去掉所有空格def trim2(string): length = len(string) start = -1 end = length - 1 return_str = [] while start &lt; end: start += 1 if string[start] == ' ': continue else: return_str.append(string[start]) #序列转化字符串 return ''.join(return_str)print('原字符串:" A B C DE "') print('去掉所有空格: "%s%s'%(trim2(' A B C DE '),'"'))#去除字符串前后任意多空格def trim3(string): length = len(string) start = 0 end = length - 1 for i in range(length): if string[start] == ' ': start += 1 if string[end] == ' ': end -= 1 if start &gt; end: break return string[start:end+1]print('去除字符串前后任意多空格:"%s%s'%(trim3(' A B C DE '),'"')) ABCD ABCD ABCD 原字符串:&quot; A B C DE &quot; 去掉所有空格: &quot;ABCDE&quot; 去除字符串前后任意多空格:&quot;A B C DE&quot; 迭代（Iteration）给定一个list或者tuple，通过for循环来遍历这个list或tuple，叫做迭代 12345678910#使用迭代查找一个list中最小和最大值，并返回一个tupledef findMinAndMax(L): max=min=None for n in L: if min==None or min&gt;n: min=n if max==None or max&lt;n: max=n return (min,max)print(findMinAndMax([1,2,3,4,5,6])) (1, 6)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day3]]></title>
    <url>%2F2019%2F05%2F29%2Fpython-20190529%2F</url>
    <content type="text"><![CDATA[函数内置函数 hex() #十六进制转换abs() #求绝对值，一个参数max() #求最大值，多个参数int() #数据类型转整型str() #数据类型转字符float() #数据类型转浮点型isinstance() #数据类型检查函数 python内置函数 定义函数空函数可以用来做占位符，函数体：pass 练习12345678y=input('输入一个数字求绝对值：')z=float(y)def abs_func(x): #def定义函数 if x&gt;=0: return x else: return -xprint(abs_func(z)) 输入一个数字求绝对值：3 3.0 1234from abstest import abs_funcz=input('输入一个数字求绝对值：')y=float(z)print(abs_func(y)) 输入一个数字求绝对值：-3 3.0 可变参数 允许传入0或任意个参数，args,接收的是一个tuple关键字参数 允许传入0或任意个含参数名的参数，kw，接收的是一个dict 命名关键字参数** 限制关键字参数的名字，需要一个特殊分隔符 ，后面的参数被视为命名关键字参数参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数 12345678910#计算坐标import mathdef move(x,y,step,angle=0): nx=x+step*math.cos(angle) ny=y-step*math.sin(angle) return nx,nyx,y=move(100,100,60,math.pi/6)print(x,y)r=move(100,100,60,math.pi/6) #返回tupleprint(r) 151.96152422706632 70.0 (151.96152422706632, 70.0) 123456789101112#求一元二次方程解import mathdef quadratic(a, b, c): m=b*b-4*a*c if m&lt;0: raise Exception('此题无解') n=math.sqrt(m) x1=(-b-n)/2*a x2=(-b+n)/2*a return x1,x2result=quadratic(2,3,1)print(result) (-4.0, -2.0) 123456789#计算x的n次方def power(x,n=2): s=1 while n&gt;0: n=n-1 s=s*x return sprint(power(2,3))print(power(2)) #默认n=2 8 4 12345#kw关键字参数def person(name,age,**kw): print('name',name,'age',age,'other',kw)extract=&#123;'job':'teacher','gender':'M'&#125;person('IVY',20,**extract) name IVY age 20 other {&#39;job&#39;: &#39;teacher&#39;, &#39;gender&#39;: &#39;M&#39;} 123456789101112131415#多个参数相乘def product(*args): if len(args)==0: raise Exception('参数为空') else: s=1 for n in args: s=s*n return sdef product1(x,*y): for i in y: x*=i return xprint(product(1,2,3,4))print(product1(2,3)) 24 6 12345678#递归函数 尾递归，防止栈溢出def fact(n): return fact_iter(n,1)def fact_iter(num,product): if num==1: return product return fact_iter(num-1,num*product)print(fact(5)) 120 123456789#汉诺塔def hanoi(n,a,b,c): #把a柱所有的圆盘移到c柱 if n == 1: print(a,'--&gt;',c) #如果a柱只剩下1个圆盘，移到c柱 else: hanoi(n-1,a,c,b) #剩下的n-1移到b柱 hanoi(1,a,b,c) #a柱剩下的一个圆盘移到c柱 hanoi(n-1,b,a,c) #剩下的n-1从b柱移到c柱hanoi(3,'A','B','C') A --&gt; C A --&gt; B C --&gt; B A --&gt; C B --&gt; A B --&gt; C A --&gt; C]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day2]]></title>
    <url>%2F2019%2F05%2F28%2Fpython-20190528%2F</url>
    <content type="text"><![CDATA[条件判断12345678#条件判断age = 3if age &gt;= 18: print('Adult')elif age&gt;6: print('Teenager')else: print('Kid') Kid 123456s = input('birth is : ')birth = int(s)if birth &lt; 2000: print('00前')else: print('00后') birth is : 1995 00前 12345678910111213141516print('格式 身高：1.75m 体重：80.5kg')a = input('Your height : ')b = input('Your weight : ')height = float(a)weight = float(b)bmi=weight/(height*height)if bmi&gt;32: print('Your BMI is : ',bmi,'严重肥胖')elif bmi&gt;28: print('Your BMI is : ',bmi,'肥胖')elif bmi&gt;25: print('Your BMI is : ',bmi,'过重')elif bmi&gt;18.5: print('Your BMI is : ',bmi,'正常')else: print('Your BMI is : ',bmi,'过轻') 格式 身高：1.75m 体重：80.5kg Your height : 1.75 Your weight : 68 Your BMI is : 22.20408163265306 正常 循环for…in 123names=['A','B','C','D']for name in names: print(name) A B C D 1234sum=0for x in range(101): #整数序列函数 sum=sum+xprint(sum) 5050 while 1234567#whilesum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) 2500 123L = ['Bart', 'Lisa', 'Adam']for x in L: print(x) Bart Lisa Adam 1234567n = 1while n &lt;=100: if n&gt;5: break #提前结束循环 print(n) n=n+1print('end') 1 2 3 4 5 end 123456n=0while n &lt; 10: n=n+1 if n%2==0: continue #跳过这次循环，直接进行到下次 print(n) 1 3 5 7 9 dict内置字典：dict，使用键-值（key-value）存储，具有极快的查找速度和list相比，dict查找的插入速度极快，但是占用大量内存，内存浪费多12345678910#dictd=&#123;'MARY':90, 'JOHN':80, 'ALICE':95&#125;print(d)d['MARY']=80print(d['MARY'])d.pop('ALICE')print(d)print(d.get('ALICE',-1)) {&#39;MARY&#39;: 90, &#39;JOHN&#39;: 80, &#39;ALICE&#39;: 95} 80 {&#39;MARY&#39;: 80, &#39;JOHN&#39;: 80} -1 setset也是一组key的集合，但是不存储value，set中无重复的key。创建一个set，需要提供一个list作为输入集合。 12345678910#sets1=set([1,2,3])print(s)s1.add(4)print(s)s1.remove(4)print(s)s2=set([3,4,5])print(s1&amp;s2)print(s1|s2) {1, 2, 3} {1, 2, 3} {1, 2, 3} {3} {1, 2, 3, 4, 5} 小结：条件判断格式 if:…elif:…else:循环 第一种 while:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种 for…in:循环控制：break，continue 元素可变：list，dict，set元素不可变：tuple]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day1]]></title>
    <url>%2F2019%2F05%2F27%2Fpython-20190527%2F</url>
    <content type="text"><![CDATA[首先进行环境安装（Mac）1.python安装 brew install pythonpython -V &nbsp; //版本查看 2.jupyter安装 pip3 install jupyterjupyter notebook &nbsp; //启动服务 环境配置好后，小白开始学习python啦～[python学习资料链接]（https://www.liaoxuefeng.com/wiki/1016959663602400） python基础注释用#标记，转义字符用\标记等号=是赋值语句，可以把任意数据类型赋值给变量，同一变量可以被反复赋值，且可以是不同类型的变量。动态语言。 格式化字符串：% %s 表示用字符串替换； %d 表示用整数替换 %f 表示用浮点数替换 练习>&gt; print(‘hello,%s~ %d day fighting!’%(‘cuify’,1))hello,cuify~ 1 day fighting! list有序列表，可以随时添加和删除其中的元素123456789#listclassmates=['TOM','JACK','MARY']classmates.append('ALICE') #添加元素classmates.insert(1,'JOHN') #插入元素print(classmates)classmates.pop(1) #pop(i) i是索引位置，没写的话会删除最后一个元素print(classmates)classmates[1]='IVY'print(classmates) [&#39;TOM&#39;, &#39;JOHN&#39;, &#39;JACK&#39;, &#39;MARY&#39;, &#39;ALICE&#39;] [&#39;TOM&#39;, &#39;JACK&#39;, &#39;MARY&#39;, &#39;ALICE&#39;] [&#39;TOM&#39;, &#39;IVY&#39;, &#39;MARY&#39;, &#39;ALICE&#39;] 123s=['apple','banana','peach']p=['watermelon',s,'grape'] print(p) [&#39;watermelon&#39;, [&#39;apple&#39;, &#39;banana&#39;, &#39;peach&#39;], &#39;grape&#39;] tuple有序列表，一旦初始化就不能修改。tuple的元素不变指的是tuple的每个元素，指向永不变。 123#tupleclassmates=('TOM','JACK','MARY')print(classmates) (&#39;TOM&#39;, &#39;JACK&#39;, &#39;MARY&#39;) 12345s=('a','b',['X','Y'],'c')print(s)s[2][0]= 'D'print(s)s[1]='r' #元素不可替换 (&#39;a&#39;, &#39;b&#39;, [&#39;X&#39;, &#39;Y&#39;], &#39;c&#39;) (&#39;a&#39;, &#39;b&#39;, [&#39;D&#39;, &#39;Y&#39;], &#39;c&#39;) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-62-e6a11ff7e543&gt; in &lt;module&gt; 3 s[2][0]= &#39;D&#39; 4 print(s) ----&gt; 5 s[1]=&#39;r&#39; TypeError: &#39;tuple&#39; object does not support item assignment]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统工程师软考知识点整理]]></title>
    <url>%2F2019%2F05%2F23%2F%E8%BD%AF%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[数据库系统工程师-软考知识点整理 💯1.音频数字化过程中采样频率应为声音最高频率2倍 2.编译过程：词法分析阶段&gt;语法分析阶段&gt;语义分析阶段&gt;中间代码生成&gt;目标代码生成 3.面向对象方法中的多态：不同类的对象对同一消息做出不同响应。三个条件为有继承关系、子类重写父类方法、父类引用指向子类对象 4.外模式/模式：数据与程序的逻辑独立性，简称数据的逻辑独立性 模式/内模式：数据与程序的物理独立性，简称数据的物理独立性 5.数据模型三要素：数据结构、数据操纵、完整性约束 6.候选码只出现在左边 7.无损连接性判断：存在R1∩R2-&gt;R1-R2或R1∩R2-&gt;R2-R1被F逻辑蕴含的情况，则具有无损连接性无损联接分解是将一个关系模式分解成若干个关系模式后，通过自然联接和投影等运算仍能还原到原来的关系模式，则称这种分解为无损联接分解。 8.满足函数依赖的条件：分解后所有的关系模式加起来和原先的关系模式中的函数依赖是一样的 9.数据库概念结构设计阶段：抽象&gt;设计局部视图&gt;合并取消冲突&gt;修改重构消除冗余 10.路由策略：为了改变网络流量所经过的途径而修改路由信息的技术 11.网络层次与主要设备对应关系： 网络层-路由器，数据链路层-网桥、交换机，传输层和会话层-软件功能 12.I/O设备管理软件一般分4层：中断处理程序、设备驱动程序、与设备无关的系统软件和用户级软件 13.假如关系R和S的元数分别为r和s，那么他们的笛卡儿积就是r+s的元组组合，而若R有m个元组，S有n个元组，则R×S应有m*n个元组 14.脏读：读取未提交数据&emsp;&nbsp;不可重复读：前后多次读取，读取内容不一致&emsp;&nbsp;幻影读：前后多次读取，读取数据总量不一致 15.部分函数依赖：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。举个例子：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。 完全函数依赖：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。举个例子：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB. 传递函数依赖：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。举个例子：通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么成C传递依赖于A 16.三种范式1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项。2、第二范式（2NF）：满足第一范式，然后消除部分依赖。3、第三范式（3NF）： 满足第二范式，消除传递依赖。 17.触发器的定义：某个条件成立的时候，触发器里定义的语句就会被自动的执行。触发器不需要人为的去调用，也不能调用。(1).语句级触发器：可以在某些语句执行前或执行后被触发(2).行级触发器：在定义了触发的表中的行数据改变时就会被触发一次 18.E-R图1.三要素：实体（矩形）、属性（椭圆形）、关系（菱形）2.作为主键的属性在文字下面加下划线3.多值属性 双线椭圆表示；派生属性 虚线椭圆表示；可选属性 椭圆的文字后用(o)表示 19.三类加密算法三类：(1).对称加密：加密和解密使用相同密钥的加密算法。DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES (2).非对称加密：加密和解密使用不同密钥的加密算法，也叫公私钥加密。RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用） (3).Hash算法：Hash算法常用在不可还原的密码存储、信息完整性校验等。MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1 非对称加密算法运行速度慢，可以实现签名；对称加密算法，建议在需要加密大量数据的时候使用，提高加解密速度； 在实际的操作过程中，通常采用的方式是：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。 20.PV操作与信号量的处理有关，P表示通过，V表示释放。用一个信号量与一个消息联系起来，当信号量的值为0时，表示期望的消息尚未产生；当信号量的值非0时，表示期望的消息已经存在。用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。 21.2PL 两段锁协议定义：所有的读写操作之前均需要加锁，解锁操作后不允许出现加锁操作。S锁：加S锁后其他事务可读不可写，直至加锁事务结束；X锁：加X锁后其他事务均不可读或者写，直至事务结束；事务执行分两个阶段：1是获得封锁阶段，2是释放封锁阶段，2PL可能会产生死锁；2PL可以防止丢失修改、读脏数据等；是事务可串行化的必要条件，但不是充分条件； 22.可串行性：当一组事务交叉执行的结果和串行执行的结果一致时，这组事务具有可串行性 23.一级锁：所有写操作前加X锁，事务结束释放，可以防止丢失修改二级锁：所有写操作前加X锁，事务结束释放；读操作前加S锁，操作结束释放，可以防止丢失修改和读脏数据三级锁：所有写操作前加X锁，事务结束释放；读操作前加S锁，事务结束释放，可以防止丢失修改和读脏数据、不可重复读。]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.05.23 ☀️]]></title>
    <url>%2F2019%2F05%2F23%2F20190523%2F</url>
    <content type="text"><![CDATA[离考试还有两天，学习进度达到20%记录，😢]]></content>
      <tags>
        <tag>零零碎碎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.05.16 ☀️]]></title>
    <url>%2F2019%2F05%2F16%2F20190516%2F</url>
    <content type="text"><![CDATA[一些以前写的想法2018.10.25梦会反映现实中捕捉不到的潜意识，负面的、希望的，然而使我略微欣慰的,是我在现实中隐隐意识到了，或许我在主动面对这样自己了。 2018.11.06突然就会很想感谢生命中的贵人，感谢他们在我人生中每一个微不足道的节骨眼助了力。 2018.11.12生日周的第一天变得很亢奋，一下不能理解原来的负面情绪都是从哪来的了。 2019.2.15今天开始准备数据库系统工程师的考试，希望能坚持下去，要把大学的专业课重新看一遍，脑壳痛。脑子饱了，肚子瘪了。]]></content>
      <tags>
        <tag>零零碎碎</tag>
      </tags>
  </entry>
</search>
