<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python学习-Day4]]></title>
    <url>%2F2019%2F05%2F30%2Fpython-20190530%2F</url>
    <content type="text"><![CDATA[高级特性代码越少越好！越简单越好！ 切片（Slice）根据索引取list或tuple的部分元素list、tuple、字符串都可以使用切片 12345678910#切片L = ['A','B','C','D','E']print(L[0:3]) #从索引0开始，到索引3但不包括索引3M = list(range(20))print(M)print(M[-4:-1]) #倒数第一个元素的索引是-1print(M[:10:2]) #前10个数，每两个取一个print(M[::5]) #所有数，每五个取一个print(len(M))print(M[len(M)-1]) [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] [16, 17, 18] [0, 2, 4, 6, 8] [0, 5, 10, 15] 20 19 1234567891011121314151617181920212223242526272829303132333435363738394041424344#实现一个trim()函数，去除字符串首尾的空格def trim(string): if string[0] == ' ' and string[len(string)-1] == ' ': return string[1:len(string)-1] elif string[0] == ' ': return string[1:] elif string[len(string)-1] == ' ': return string[0:len(string)-1] else: return stringprint(trim(' ABCD '))print(trim(' ABCD'))print(trim('ABCD '))#去掉所有空格def trim2(string): length = len(string) start = -1 end = length - 1 return_str = [] while start &lt; end: start += 1 if string[start] == ' ': continue else: return_str.append(string[start]) #序列转化字符串 return ''.join(return_str)print('原字符串:"',' A B C DE ','"') print('去掉所有空格: "',trim2(' A B C DE '),'"') #去除字符串前后任意多空格def trim3(string): length = len(string) start = 0 end = length - 1 for i in range(length): if string[start] == ' ': start += 1 if string[end] == ' ': end -= 1 if start &gt; end: break return string[start:end+1]print('去除字符串前后任意多空格:"',trim3(' A B C DE '),'"') ABCD ABCD ABCD 原字符串:&quot; A B C DE &quot; 去掉所有空格: &quot; ABCDE &quot; 去除字符串前后任意多空格:&quot; A B C DE &quot; 迭代（Iteration）给定一个list或者tuple，通过for循环来遍历这个list或tuple，叫做迭代 12345678910#使用迭代查找一个list中最小和最大值，并返回一个tupledef findMinAndMax(L): max=min=None for n in L: if min==None or min&gt;n: min=n if max==None or max&lt;n: max=n return (min,max)print(findMinAndMax([1,2,3,4,5,6])) (1, 6)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day3]]></title>
    <url>%2F2019%2F05%2F29%2Fpython-20190529%2F</url>
    <content type="text"><![CDATA[函数内置函数 hex() #十六进制转换abs() #求绝对值，一个参数max() #求最大值，多个参数int() #数据类型转整型str() #数据类型转字符float() #数据类型转浮点型isinstance() #数据类型检查函数 python内置函数 定义函数空函数可以用来做占位符，函数体：pass 练习12345678y=input('输入一个数字求绝对值：')z=float(y)def abs_func(x): #def定义函数 if x&gt;=0: return x else: return -xprint(abs_func(z)) 输入一个数字求绝对值：3 3.0 1234from abstest import abs_funcz=input('输入一个数字求绝对值：')y=float(z)print(abs_func(y)) 输入一个数字求绝对值：-3 3.0 可变参数 允许传入0或任意个参数，args,接收的是一个tuple关键字参数 允许传入0或任意个含参数名的参数，kw，接收的是一个dict 命名关键字参数** 限制关键字参数的名字，需要一个特殊分隔符 ，后面的参数被视为命名关键字参数参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数 12345678910#计算坐标import mathdef move(x,y,step,angle=0): nx=x+step*math.cos(angle) ny=y-step*math.sin(angle) return nx,nyx,y=move(100,100,60,math.pi/6)print(x,y)r=move(100,100,60,math.pi/6) #返回tupleprint(r) 151.96152422706632 70.0 (151.96152422706632, 70.0) 123456789101112#求一元二次方程解import mathdef quadratic(a, b, c): m=b*b-4*a*c if m&lt;0: raise Exception('此题无解') n=math.sqrt(m) x1=(-b-n)/2*a x2=(-b+n)/2*a return x1,x2result=quadratic(2,3,1)print(result) (-4.0, -2.0) 123456789#计算x的n次方def power(x,n=2): s=1 while n&gt;0: n=n-1 s=s*x return sprint(power(2,3))print(power(2)) #默认n=2 8 4 12345#kw关键字参数def person(name,age,**kw): print('name',name,'age',age,'other',kw)extract=&#123;'job':'teacher','gender':'M'&#125;person('IVY',20,**extract) name IVY age 20 other {&#39;job&#39;: &#39;teacher&#39;, &#39;gender&#39;: &#39;M&#39;} 123456789101112131415#多个参数相乘def product(*args): if len(args)==0: raise Exception('参数为空') else: s=1 for n in args: s=s*n return sdef product1(x,*y): for i in y: x*=i return xprint(product(1,2,3,4))print(product1(2,3)) 24 6 12345678#递归函数 尾递归，防止栈溢出def fact(n): return fact_iter(n,1)def fact_iter(num,product): if num==1: return product return fact_iter(num-1,num*product)print(fact(5)) 120 123456789#汉诺塔def hanoi(n,a,b,c): #把a柱所有的圆盘移到c柱 if n == 1: print(a,'--&gt;',c) #如果a柱只剩下1个圆盘，移到c柱 else: hanoi(n-1,a,c,b) #剩下的n-1移到b柱 hanoi(1,a,b,c) #a柱剩下的一个圆盘移到c柱 hanoi(n-1,b,a,c) #剩下的n-1从b柱移到c柱hanoi(3,'A','B','C') A --&gt; C A --&gt; B C --&gt; B A --&gt; C B --&gt; A B --&gt; C A --&gt; C]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day2]]></title>
    <url>%2F2019%2F05%2F28%2Fpython-20190528%2F</url>
    <content type="text"><![CDATA[条件判断12345678#条件判断age = 3if age &gt;= 18: print('Adult')elif age&gt;6: print('Teenager')else: print('Kid') Kid 123456s = input('birth is : ')birth = int(s)if birth &lt; 2000: print('00前')else: print('00后') birth is : 1995 00前 12345678910111213141516print('格式 身高：1.75m 体重：80.5kg')a = input('Your height : ')b = input('Your weight : ')height = float(a)weight = float(b)bmi=weight/(height*height)if bmi&gt;32: print('Your BMI is : ',bmi,'严重肥胖')elif bmi&gt;28: print('Your BMI is : ',bmi,'肥胖')elif bmi&gt;25: print('Your BMI is : ',bmi,'过重')elif bmi&gt;18.5: print('Your BMI is : ',bmi,'正常')else: print('Your BMI is : ',bmi,'过轻') 格式 身高：1.75m 体重：80.5kg Your height : 1.75 Your weight : 68 Your BMI is : 22.20408163265306 正常 循环for…in 123names=['A','B','C','D']for name in names: print(name) A B C D 1234sum=0for x in range(101): #整数序列函数 sum=sum+xprint(sum) 5050 while 1234567#whilesum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) 2500 123L = ['Bart', 'Lisa', 'Adam']for x in L: print(x) Bart Lisa Adam 1234567n = 1while n &lt;=100: if n&gt;5: break #提前结束循环 print(n) n=n+1print('end') 1 2 3 4 5 end 123456n=0while n &lt; 10: n=n+1 if n%2==0: continue #跳过这次循环，直接进行到下次 print(n) 1 3 5 7 9 dict内置字典：dict，使用键-值（key-value）存储，具有极快的查找速度和list相比，dict查找的插入速度极快，但是占用大量内存，内存浪费多12345678910#dictd=&#123;'MARY':90, 'JOHN':80, 'ALICE':95&#125;print(d)d['MARY']=80print(d['MARY'])d.pop('ALICE')print(d)print(d.get('ALICE',-1)) {&#39;MARY&#39;: 90, &#39;JOHN&#39;: 80, &#39;ALICE&#39;: 95} 80 {&#39;MARY&#39;: 80, &#39;JOHN&#39;: 80} -1 setset也是一组key的集合，但是不存储value，set中无重复的key。创建一个set，需要提供一个list作为输入集合。 12345678910#sets1=set([1,2,3])print(s)s1.add(4)print(s)s1.remove(4)print(s)s2=set([3,4,5])print(s1&amp;s2)print(s1|s2) {1, 2, 3} {1, 2, 3} {1, 2, 3} {3} {1, 2, 3, 4, 5} 小结：条件判断格式 if:…elif:…else:循环 第一种 while:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种 for…in:循环控制：break，continue 元素可变：list，dict，set元素不可变：tuple]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day1]]></title>
    <url>%2F2019%2F05%2F27%2Fpython-20190527%2F</url>
    <content type="text"><![CDATA[首先进行环境安装（Mac）1.python安装 brew install pythonpython -V &nbsp; //版本查看 2.jupyter安装 pip3 install jupyterjupyter notebook &nbsp; //启动服务 环境配置好后，小白开始学习python啦～[python学习资料链接]（https://www.liaoxuefeng.com/wiki/1016959663602400） python基础注释用#标记，转义字符用\标记等号=是赋值语句，可以把任意数据类型赋值给变量，同一变量可以被反复赋值，且可以是不同类型的变量。动态语言。 格式化字符串：% %s 表示用字符串替换； %d 表示用整数替换 %f 表示用浮点数替换 练习>&gt; print(‘hello,%s~ %d day fighting!’%(‘cuify’,1))hello,cuify~ 1 day fighting! list有序列表，可以随时添加和删除其中的元素123456789#listclassmates=['TOM','JACK','MARY']classmates.append('ALICE') #添加元素classmates.insert(1,'JOHN') #插入元素print(classmates)classmates.pop(1) #pop(i) i是索引位置，没写的话会删除最后一个元素print(classmates)classmates[1]='IVY'print(classmates) [&#39;TOM&#39;, &#39;JOHN&#39;, &#39;JACK&#39;, &#39;MARY&#39;, &#39;ALICE&#39;] [&#39;TOM&#39;, &#39;JACK&#39;, &#39;MARY&#39;, &#39;ALICE&#39;] [&#39;TOM&#39;, &#39;IVY&#39;, &#39;MARY&#39;, &#39;ALICE&#39;] 123s=['apple','banana','peach']p=['watermelon',s,'grape'] print(p) [&#39;watermelon&#39;, [&#39;apple&#39;, &#39;banana&#39;, &#39;peach&#39;], &#39;grape&#39;] tuple有序列表，一旦初始化就不能修改。tuple的元素不变指的是tuple的每个元素，指向永不变。 123#tupleclassmates=('TOM','JACK','MARY')print(classmates) (&#39;TOM&#39;, &#39;JACK&#39;, &#39;MARY&#39;) 12345s=('a','b',['X','Y'],'c')print(s)s[2][0]= 'D'print(s)s[1]='r' #元素不可替换 (&#39;a&#39;, &#39;b&#39;, [&#39;X&#39;, &#39;Y&#39;], &#39;c&#39;) (&#39;a&#39;, &#39;b&#39;, [&#39;D&#39;, &#39;Y&#39;], &#39;c&#39;) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-62-e6a11ff7e543&gt; in &lt;module&gt; 3 s[2][0]= &#39;D&#39; 4 print(s) ----&gt; 5 s[1]=&#39;r&#39; TypeError: &#39;tuple&#39; object does not support item assignment]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统工程师软考知识点整理]]></title>
    <url>%2F2019%2F05%2F23%2F%E8%BD%AF%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[数据库系统工程师-软考知识点整理 💯1.音频数字化过程中采样频率应为声音最高频率2倍 2.编译过程：词法分析阶段&gt;语法分析阶段&gt;语义分析阶段&gt;中间代码生成&gt;目标代码生成 3.面向对象方法中的多态：不同类的对象对同一消息做出不同响应。三个条件为有继承关系、子类重写父类方法、父类引用指向子类对象 4.外模式/模式：数据与程序的逻辑独立性，简称数据的逻辑独立性 模式/内模式：数据与程序的物理独立性，简称数据的物理独立性 5.数据模型三要素：数据结构、数据操纵、完整性约束 6.候选码只出现在左边 7.无损连接性判断：存在R1∩R2-&gt;R1-R2或R1∩R2-&gt;R2-R1被F逻辑蕴含的情况，则具有无损连接性无损联接分解是将一个关系模式分解成若干个关系模式后，通过自然联接和投影等运算仍能还原到原来的关系模式，则称这种分解为无损联接分解。 8.满足函数依赖的条件：分解后所有的关系模式加起来和原先的关系模式中的函数依赖是一样的 9.数据库概念结构设计阶段：抽象&gt;设计局部视图&gt;合并取消冲突&gt;修改重构消除冗余 10.路由策略：为了改变网络流量所经过的途径而修改路由信息的技术 11.网络层次与主要设备对应关系： 网络层-路由器，数据链路层-网桥、交换机，传输层和会话层-软件功能 12.I/O设备管理软件一般分4层：中断处理程序、设备驱动程序、与设备无关的系统软件和用户级软件 13.假如关系R和S的元数分别为r和s，那么他们的笛卡儿积就是r+s的元组组合，而若R有m个元组，S有n个元组，则R×S应有m*n个元组 14.脏读：读取未提交数据&emsp;&nbsp;不可重复读：前后多次读取，读取内容不一致&emsp;&nbsp;幻影读：前后多次读取，读取数据总量不一致 15.部分函数依赖：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。举个例子：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。 完全函数依赖：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。举个例子：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB. 传递函数依赖：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。举个例子：通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么成C传递依赖于A 16.三种范式1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项。2、第二范式（2NF）：满足第一范式，然后消除部分依赖。3、第三范式（3NF）： 满足第二范式，消除传递依赖。 17.触发器的定义：某个条件成立的时候，触发器里定义的语句就会被自动的执行。触发器不需要人为的去调用，也不能调用。(1).语句级触发器：可以在某些语句执行前或执行后被触发(2).行级触发器：在定义了触发的表中的行数据改变时就会被触发一次 18.E-R图1.三要素：实体（矩形）、属性（椭圆形）、关系（菱形）2.作为主键的属性在文字下面加下划线3.多值属性 双线椭圆表示；派生属性 虚线椭圆表示；可选属性 椭圆的文字后用(o)表示 19.三类加密算法三类：(1).对称加密：加密和解密使用相同密钥的加密算法。DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES (2).非对称加密：加密和解密使用不同密钥的加密算法，也叫公私钥加密。RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用） (3).Hash算法：Hash算法常用在不可还原的密码存储、信息完整性校验等。MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1 非对称加密算法运行速度慢，可以实现签名；对称加密算法，建议在需要加密大量数据的时候使用，提高加解密速度； 在实际的操作过程中，通常采用的方式是：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。 20.PV操作与信号量的处理有关，P表示通过，V表示释放。用一个信号量与一个消息联系起来，当信号量的值为0时，表示期望的消息尚未产生；当信号量的值非0时，表示期望的消息已经存在。用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。 21.2PL 两段锁协议定义：所有的读写操作之前均需要加锁，解锁操作后不允许出现加锁操作。S锁：加S锁后其他事务可读不可写，直至加锁事务结束；X锁：加X锁后其他事务均不可读或者写，直至事务结束；事务执行分两个阶段：1是获得封锁阶段，2是释放封锁阶段，2PL可能会产生死锁；2PL可以防止丢失修改、读脏数据等；是事务可串行化的必要条件，但不是充分条件； 22.可串行性：当一组事务交叉执行的结果和串行执行的结果一致时，这组事务具有可串行性 23.一级锁：所有写操作前加X锁，事务结束释放，可以防止丢失修改二级锁：所有写操作前加X锁，事务结束释放；读操作前加S锁，操作结束释放，可以防止丢失修改和读脏数据三级锁：所有写操作前加X锁，事务结束释放；读操作前加S锁，事务结束释放，可以防止丢失修改和读脏数据、不可重复读。]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.05.23 ☀️]]></title>
    <url>%2F2019%2F05%2F23%2F20190523%2F</url>
    <content type="text"><![CDATA[离考试还有两天，学习进度达到20%记录，😢]]></content>
      <tags>
        <tag>零零碎碎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.05.16 ☀️]]></title>
    <url>%2F2019%2F05%2F16%2F20190516%2F</url>
    <content type="text"><![CDATA[一些以前写的想法2018.10.25梦会反映现实中捕捉不到的潜意识，负面的、希望的，然而使我略微欣慰的,是我在现实中隐隐意识到了，或许我在主动面对这样自己了。 2018.11.06突然就会很想感谢生命中的贵人，感谢他们在我人生中每一个微不足道的节骨眼助了力。 2018.11.12生日周的第一天变得很亢奋，一下不能理解原来的负面情绪都是从哪来的了。 2019.2.15今天开始准备数据库系统工程师的考试，希望能坚持下去，要把大学的专业课重新看一遍，脑壳痛。脑子饱了，肚子瘪了。]]></content>
      <tags>
        <tag>零零碎碎</tag>
      </tags>
  </entry>
</search>
