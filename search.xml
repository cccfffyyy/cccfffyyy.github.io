<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python学习-Day14]]></title>
    <url>%2F2019%2F06%2F20%2Fpython-20190620%2F</url>
    <content type="text"><![CDATA[多线程Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行。 12345678910111213141516import time,threadingdef loop(): print('thread is running...%s...'%threading.current_thread().name) #返回当前线程的实例 current_thread() n = 1 while n &lt; 5: n += 1 print('thread %s&gt;&gt;&gt;%s'%(threading.current_thread().name,n)) time.sleep(1) print('thread %s ended'%threading.current_thread().name) print('thread is running...%s...'%threading.current_thread().name) #主线程名字的实例MainThreadt = threading.Thread(target = loop ,name = 'LoopThread') #子线程名字在创建时指定t.start()t.join()print('thread %s ended'%threading.current_thread().name) thread is running...MainThread... thread is running...LoopThread... thread LoopThread&gt;&gt;&gt;2 thread LoopThread ended thread LoopThread&gt;&gt;&gt;3 thread LoopThread ended thread LoopThread&gt;&gt;&gt;4 thread LoopThread ended thread LoopThread&gt;&gt;&gt;5 thread LoopThread ended thread MainThread ended threading.Lock()由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。创建一个锁就是通过threading.Lock()来实现。 12345678910111213141516171819202122232425import time,threadingbalance = 0 #存款lock = threading.Lock() #锁 加入锁是为了避免修改冲突def change_it(n): global balance balance = balance + n balance = balance - ndef run_thread(n): for i in range(100): lock.acquire() #先获取锁 try: change_it(n) finally: lock.release() #改完了一定要释放锁t1 = threading.Thread(target = run_thread,args = (5,))t2 = threading.Thread(target = run_thread,args = (8,))t1.start()t2.start()t1.join()t2.join()print(balance) 0]]></content>
      <tags>
        <tag>python</tag>
        <tag>多线程</tag>
        <tag>threading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day13]]></title>
    <url>%2F2019%2F06%2F14%2Fpython-20190614%2F</url>
    <content type="text"><![CDATA[多进程Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。 123456789import osprint('Process %s start...'%os.getpid()) #获取当前进程pid = os.fork() #子进程永远返回0，而父进程返回子进程的IDif pid == 0: print('I am child process %s , and my parent process is %s'%(os.getpid(),os.getppid()))else: print('I am %s,just created process %s'%(os.getpid(),pid)) Process 46683 start... I am 46683,just created process 46785 I am child process 46785 , and my parent process is 46683 multiprocessingmultiprocessing模块就是跨平台版本的多进程模块。 Process提供了一个Process类来代表一个进程对象。 12345678910111213from multiprocessing import Processimport osdef run(name): print('Run child process %s is %s'%(name,os.getpid()))if __name__ == '__main__': print('Parent process %s'%os.getpid()) p = Process(target = run,args = ('进程',)) print('Child process will start...') p.start() #启动 p.join() #等待子进程结束后继续向下运行，通常用于进程间的同步 print('Child process end...') Parent process 46683 Child process will start... Run child process 进程 is 46837 Child process end... 进程池(Pool) 12345678910111213141516171819from multiprocessing import Poolimport os,time,randomdef long_time_task(name): print('Run task %s is %s'%(name,os.getpid())) start = time.time() time.sleep(random.random()*3) end = time.time() print('Task %s runs %0.2f s.'%(name,(end-start)))if __name__ == '__main__': print('Parent process is %s'%os.getpid()) p = Pool(4) #最多同时跑4个进程，默认是CPU核数 for i in range(5): p.apply_async(long_time_task,args = (i,)) print('Waiting for all subprocesses done...') p.close() p.join() #join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了 print('All subprocesses done.') Parent process is 46683 Run task 0 is 46895 Run task 1 is 46896 Run task 2 is 46897 Run task 3 is 46898 Task 2 runs 0.14 s. Run task 4 is 46897 Waiting for all subprocesses done... Task 3 runs 0.29 s. Task 0 runs 2.76 s. Task 1 runs 2.90 s. Task 4 runs 2.95 s. All subprocesses done. 子进程subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。 12345678910111213141516171819202122232425#进程间通信from multiprocessing import Process,Queueimport osdef write(q): print('写进程：',os.getpid()) for value in ['A','B','C']: print('将%s插入queue'%value) q.put(value) time.sleep(random.random()) def read(q): print('读进程：',os.getpid()) while True: value = q.get(True) print('得到值%s'%value)if __name__ =='__main__': q = Queue() pw = Process(target = write,args =(q,) ) pr = Process(target = read,args = (q,)) pw.start() pr.start() pw.join() pr.terminate() # pr进程里是死循环，无法等待其结束，只能强行终止: 写进程： 47442 读进程： 47443 将A插入queue 得到值A 将B插入queue 得到值B 将C插入queue 得到值C]]></content>
      <tags>
        <tag>python</tag>
        <tag>多进程</tag>
        <tag>multiprocessing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day12]]></title>
    <url>%2F2019%2F06%2F12%2Fpython-20190612%2F</url>
    <content type="text"><![CDATA[IO编程文件读写磁盘上读写文件的功能都是操作系统提供的，读写文件就是请求操作系统打开一个文件对象（文件描述符），然后通过操作系统提供的接口从这个文件对象中读取数据，或者把数据写入这个文件对象。 读文件要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的 1234567#读文件try: #无论是否出错，都关闭文件 f = open('./err.py','r') #打开一个文件，r 代表读 print(f.read()) #一次读取全部内容，读到内存，用str表示finally: if f: f.close() #关闭文件 #err.py import pdb s = &#39;0&#39; n = int(s) pdb.set_trace() #运行到这里会自动暂停 print(10 / n) 12345#更加简洁的写法，和try...finally一样with open('./err.py','r') as f: #with语句可以自动调用close方法 print(f.read(4)) #read(size) 最多读取size个字节的内容 print(f.readline()) #每次读取一行内容 print(f.readlines()) #一次读取所有内容并按行返回list，读取配置文件比较合适 #err .py [&#39;import pdb\n&#39;, &#39;\n&#39;, &quot;s = &#39;0&#39;\n&quot;, &#39;n = int(s)\n&#39;, &#39;pdb.set_trace() #运行到这里会自动暂停\n&#39;, &#39;print(10 / n)\n&#39;] 12345678try: f = open('./gbk.txt','rb') #rb 二进制 print(f.read()) f2 = open('./gbk.txt','r',encoding = 'utf-8', errors = 'ignore') #encoding 编码；errors 忽略编码错误 print(f2.read())finally: f.close() f2.close() b&#39;\xe6\xb5\x8b\xe8\xaf\x95\n&#39; 测试 写文件写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件。以’w’模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入’a’以追加（append）模式写入。 123456789#写文件with open('./gbk.txt','w') as f: #w完全覆盖 f.write('写一行文本进去～')with open('./gbk.txt','r') as f: print(f.read())with open('./gbk.txt','a') as f: #追加 append f.write('追加文本～')with open('./gbk.txt','r') as f: print(f.read()) 写一行文本进去～ 写一行文本进去～追加文本～ StringIOStringIO顾名思义就是在内存中读写str。要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可 1234567891011121314#StringIO ##BytesIO 和StringIO一样，只是操作的是二进制数据，不是str，在这里就不写了from io import StringIOf = StringIO()f.write('hey ')f.write('buddy~')print(f.getvalue()) #getvalue获取写入后的strt = StringIO('今天\n天气\n真不错') #初始化一个strwhile True: s = t.readline() if s == '': break print(s.strip()) #strip用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列 hey buddy~ 今天 天气 真不错 BytesIO和StringIO一样，只是操作的是二进制数据 操作文件和目录Python的os模块封装了操作系统的目录和文件操作，要注意这些函数有的在os模块中，有的在os.path模块中。 查看当前目录的绝对路径:>&gt;&gt; os.path.abspath(‘.’)‘/Users/michael’在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:>&gt;&gt; os.path.join(‘/Users/michael’, ‘testdir’)‘/Users/michael/testdir’然后创建一个目录:>&gt;&gt; os.mkdir(‘/Users/michael/testdir’)删掉一个目录:>&gt;&gt; os.rmdir(‘/Users/michael/testdir’)拆分路径>&gt;&gt;os.path.split(‘/Users/michael/testdir/file.txt’)(‘/Users/michael/testdir’, ‘file.txt’)得到文件扩展名>&gt;&gt; os.path.splitext(‘/path/to/file.txt’)(‘/path/to/file’, ‘.txt’)对文件重命名:>&gt;&gt; os.rename(‘test.txt’, ‘test.py’)删掉文件:>&gt;&gt; os.remove(‘test.py’) 12345678910#编写一个程序，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出相对路径。import osdef printFileName(path, key_word): #传入路径 和 关键字 for x in os.listdir(path): if os.path.isdir(os.path.join(path, x)): printFileName(os.path.join(path, x), key_word) elif key_word in os.path.splitext(x)[0]: print(os.path.join(path, x))printFileName('.','0604') ./190604.ipynb ./.ipynb_checkpoints/190604-checkpoint.ipynb 序列化(pickling) 反序列化(unpickling)Python语言特定的序列化模块是pickle，但如果要把序列化搞得更通用、更符合Web标准，就可以使用json模块。 123456789#序列化两种方式import pickled = dict(name = 'Bob',age = 20, score = 80)f = open('./dump.txt','wb')pickle.dump(d,f) #序列化f.close()with open('./dump.txt','rb') as f: d = pickle.load(f) #反序列化 print(d) {&#39;name&#39;: &#39;Bob&#39;, &#39;age&#39;: 20, &#39;score&#39;: 80} 123456789import pickled = dict(eat = '草莓',drink = '奶茶')b = pickle.dumps(d) #把任意对象序列化成一个byteswith open('./dump.txt','wb') as f: f.write(b)with open('./dump.txt','rb') as f: d = f.read() d = pickle.loads(d) #反序列化 print(d) {&#39;eat&#39;: &#39;草莓&#39;, &#39;drink&#39;: &#39;奶茶&#39;} 123456#python 内置 jsonimport jsond = dict(name='Bob', age=20, score=88)print(json.dumps(d)) #python 转化为 jsonjson_str = '&#123;"age": 20, "score": 88, "name": "Bob"&#125;'print(json.loads(json_str)) #json 反序列化为 python对象 {&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 20, &quot;score&quot;: 88} {&#39;age&#39;: 20, &#39;score&#39;: 88, &#39;name&#39;: &#39;Bob&#39;}]]></content>
      <tags>
        <tag>python</tag>
        <tag>IO编程</tag>
        <tag>文件读写</tag>
        <tag>StringIO和BytesIO</tag>
        <tag>json</tag>
        <tag>序列化</tag>
        <tag>操作文件和目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day11]]></title>
    <url>%2F2019%2F06%2F11%2Fpython-20190611%2F</url>
    <content type="text"><![CDATA[type()函数可以查看一个类型或变量的类型。动态创建class的方法就是使用type()函数。 要创建一个class对象，type()函数依次传入3个参数: class的名称； 继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法； class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。 123456789#利用type()动态创建classdef fn(self,name = 'world'): print('Hello:%s'%name)Hello = type('Hello',(object,),dict(hello=fn)) #创建Hello class，依次传入 类名、继承的父类(tuple),方法名与函数绑定h = Hello()h.hello()print(type(Hello))print(type(h)) Hello:world &lt;class &#39;type&#39;&gt; &lt;class &#39;__main__.Hello&#39;&gt; tuple单元素写法：因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义 错误、调试和测试错误处理当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。所有的错误类型都继承自BaseException。 12345678910111213try: print ('try...') r = 10 / int('a') print('result:',r)except ZeroDivisionError as e: print ('except:',e)except ValueError as v: print ('except',v)else: print ('no error')finally: print ('finally...')print('end') try... except invalid literal for int() with base 10: &#39;a&#39; finally... end 1234567891011121314def foo(s): return 10 / int(s)def bar(s): return foo(s) * 2def main(): try: bar('0') except Exception as e: #main函数捕捉到foo的异常 print('Error:', e) finally: print('finally...')main() Error: division by zero finally... 记录错误Python内置的logging模块可以非常容易地记录错误信息。 123456789101112131415import loggingdef foo(s): return 10 / int(s)def bar(s): return foo(s) * 2def main(): try: bar('0') except Exception as e: logging.exception(e)main()print('END') #打印错误后继续执行程序 ERROR:root:division by zero Traceback (most recent call last): File &quot;&lt;ipython-input-23-548d57022a52&gt;&quot;, line 11, in main bar(&#39;0&#39;) File &quot;&lt;ipython-input-23-548d57022a52&gt;&quot;, line 7, in bar return foo(s) * 2 File &quot;&lt;ipython-input-23-548d57022a52&gt;&quot;, line 4, in foo return 10 / int(s) ZeroDivisionError: division by zero END 抛出错误如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用raise语句抛出一个错误的实例。 12345678910class FooError(ValueError): #定义一个错误的class类 passdef foo(s): n = int(s) if n == 0: raise FooError('invalid number: %s'%s) #抛出一个错误实例 return 10 / nfoo('0') --------------------------------------------------------------------------- FooError Traceback (most recent call last) &lt;ipython-input-26-333227bdf036&gt; in &lt;module&gt; 8 return 10 / n 9 ---&gt; 10 foo(&#39;0&#39;) &lt;ipython-input-26-333227bdf036&gt; in foo(s) 5 n = int(s) 6 if n == 0: ----&gt; 7 raise FooError(&#39;invalid number: %s&#39;%s) #抛出一个错误实例 8 return 10 / n 9 FooError: invalid number: 0 1234567891011121314def foo(s): n = int(s) if n==0: raise ValueError('invalid value: %s' % s) return 10 / ndef bar(): try: foo('0') except ValueError as e: print('ValueError!') raisebar() ValueError! --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-27-afddea58d827&gt; in &lt;module&gt; 12 raise 13 ---&gt; 14 bar() &lt;ipython-input-27-afddea58d827&gt; in bar() 7 def bar(): 8 try: ----&gt; 9 foo(&#39;0&#39;) 10 except ValueError as e: 11 print(&#39;ValueError!&#39;) &lt;ipython-input-27-afddea58d827&gt; in foo(s) 2 n = int(s) 3 if n==0: ----&gt; 4 raise ValueError(&#39;invalid value: %s&#39; % s) 5 return 10 / n 6 ValueError: invalid value: 0 1234567891011121314151617181920from functools import reducedef str2num(s): try: return(int(s)) except ValueError as e: return float(s) def calc(exp): ss = exp.split('+') ns = map(str2num, ss) return reduce(lambda acc, x: acc + x, ns)def main(): r = calc('100 + 200 + 345') print('100 + 200 + 345 =', r) r = calc('99 + 88 + 7.6') print('99 + 88 + 7.6 =', r) main() 100 + 200 + 345 = 645 99 + 88 + 7.6 = 194.6 调试五种方式： print() 打印出来 断言(assert) 启动Python解释器时可以用-O参数来关闭assert 1234567#断言def foo(s): n = int(s) assert n != 0, '0 is zero!' return 10 / nfoo('0') --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) &lt;ipython-input-39-ac4ec61a0154&gt; in &lt;module&gt; 5 return 10 / n 6 ----&gt; 7 foo(&#39;0&#39;) &lt;ipython-input-39-ac4ec61a0154&gt; in foo(s) 2 def foo(s): 3 n = int(s) ----&gt; 4 assert n != 0, &#39;0 is zero!&#39; 5 return 10 / n 6 AssertionError: 0 is zero! logging 不会抛出错误，而且可以输出到文件。这就是logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。 123456import logginglogging.basicConfig(level=logging.INFO)s = '0'n = int(s)logging.info('n = %d' % n)print(10 / n) --------------------------------------------------------------------------- ZeroDivisionError Traceback (most recent call last) &lt;ipython-input-45-c42985358872&gt; in &lt;module&gt; 4 n = int(s) 5 logging.info(&#39;n = %d&#39; % n) ----&gt; 6 print(10 / n) ZeroDivisionError: division by zero pdb python -m pdb err.py 输入命令l来查看代码输入命令n可以单步执行代码任何时候都可以输入命令p 变量名来查看变量输入命令q结束调试，退出程序 只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点 IDEPyCharm/VSCODE 1234567891011121314151617#单元测试 class Dict(dict): def __init__(self, **kw): super().__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r"'Dict' object has no attribute '%s'" % key) def __setattr__(self, key, value): self[key] = valued = Dict(a = 1,b = 2)d['a'] 1 单元测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#单元测试# -*- coding: utf-8 -*-import unittestclass Student(object): def __init__(self, name, score): self.name = name self.score = score def get_grade(self): if self.score &gt; 100 or self.score &lt; 0: raise ValueError elif self.score &gt;= 80: return 'A' elif self.score &gt;= 60: return 'B' else: return 'C' class TestStudent(unittest.TestCase): def test_80_to_100(self): s1 = Student('Bart', 80) s2 = Student('Lisa', 100) self.assertEqual(s1.get_grade(), 'A') self.assertEqual(s2.get_grade(), 'A') def test_60_to_80(self): s1 = Student('Bart', 60) s2 = Student('Lisa', 79) self.assertEqual(s1.get_grade(), 'B') self.assertEqual(s2.get_grade(), 'B') def test_0_to_60(self): s1 = Student('Bart', 0) s2 = Student('Lisa', 59) self.assertEqual(s1.get_grade(), 'C') self.assertEqual(s2.get_grade(), 'C') def test_invalid(self): s1 = Student('Bart', -1) s2 = Student('Lisa', 101) with self.assertRaises(ValueError): s1.get_grade() with self.assertRaises(ValueError): s2.get_grade() if __name__ == '__main__': unittest.main(argv=['first-arg-is-ignored'],exit=False) ......... ---------------------------------------------------------------------- Ran 9 tests in 0.021s OK ps:文档测试没看懂，以后有需要的时候再回顾]]></content>
      <tags>
        <tag>python</tag>
        <tag>调试</tag>
        <tag>异常</tag>
        <tag>动态创建class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day10]]></title>
    <url>%2F2019%2F06%2F10%2Fpython-20190610%2F</url>
    <content type="text"><![CDATA[多重继承通过多重继承，一个子类可以同时获得多个父类的所有功能。这种设计通常称之为MixIn。 12345678910111213141516171819202122232425262728class Animal(object): passclass Mammal(Animal): def mam(self): print('mammal')class Bird(Animal): passclass Runnable(object): def run(self): print('It can run')class Flyable(object): def fly(self): print('It can fly') class Dog(Mammal,Runnable): passclass Parrot(Bird,Flyable): passdog=Dog()parrot = Parrot()print(dog.run())print(dog.mam()) It can run None mammal None 定制类__str__() 定义该方法，就能返回一个好看的字符串。 1234567#__str__class Student(object): def __init__(self,name): self.name = name def __str__(self): return 'Student object name %s' % self.nameprint(Student('Micheal')) Student object name Micheal __iter__ 定义该方法，类可以用作for…in循环，返回一个迭代对象。Python的for循环就会不断调用该迭代对象的next()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。要表现得像list那样按照下标取出元素，需要实现getitem()方法。写一个getattr()方法，动态返回一个属性。__call__()方法，可以直接对实例进行调。 123456789101112131415161718192021222324252627282930313233#__iter__class Fib(object): def __init__(self): self.a,self.b = 0,1 #初始化两个计数器 def __iter__(self): return self def __next__(self): self.a , self.b=self.b , self.a + self.b if self.a&gt;1000: raise StopIteration() return self.a def __getitem__(self,n): #像list一样按下标取数 if isinstance(n,int): a , b = 1 , 1 for x in range(n): a , b = b , a + b return a if isinstance(n,slice): #判断切片 start = n.start stop = n.stop if start is None: start = 0 a , b = 1 , 1 L = [] for x in range(stop): if x &gt;=start: L.append(a) a , b = b , a + b return Lfor n in Fib(): print(n)f = Fib()f[0:5] 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 [1, 1, 2, 3, 5] 12345678class Student(object): def __init__(self,name): self.name = name def __getattr__(self,attr): #调用不存在的属性，会通过__getattr__尝试获得属性 if attr == 'score': return 99s = Student('Lucy')s.score 99 1234567891011121314#链式调用class Chain(object): def __init__(self,path = ''): self._path = path def __getattr__(self,path): return Chain('%s/%s'%(self._path,path)) def __str__(self): return self._path def __call__(self): return '直接调用实例' __repr__ = __str__ #调试print(Chain().status.user.timeline.list)c = Chain()c() /status/user/timeline/list &#39;直接调用实例&#39; 枚举类123456789101112131415161718#枚举from enum import Enum,uniqueMonth = Enum('Month',('Jan','Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))for name,member in Month.__members__.items(): print(name,'=&gt;',member,',',member.value) #value属性则是自动赋给成员的int常量，默认从1开始计数。@unique #unique可以帮忙看有没有重复值class Week(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6print('-------------')for name,member in Week.__members__.items(): print(name,',',member,',',member.value) Jan =&gt; Month.Jan , 1 Feb =&gt; Month.Feb , 2 Mar =&gt; Month.Mar , 3 Apr =&gt; Month.Apr , 4 May =&gt; Month.May , 5 Jun =&gt; Month.Jun , 6 Jul =&gt; Month.Jul , 7 Aug =&gt; Month.Aug , 8 Sep =&gt; Month.Sep , 9 Oct =&gt; Month.Oct , 10 Nov =&gt; Month.Nov , 11 Dec =&gt; Month.Dec , 12 ------------- Sun , Week.Sun , 0 Mon , Week.Mon , 1 Tue , Week.Tue , 2 Wed , Week.Wed , 3 Thu , Week.Thu , 4 Fri , Week.Fri , 5 Sat , Week.Sat , 6]]></content>
      <tags>
        <tag>python</tag>
        <tag>多重继承</tag>
        <tag>定制类</tag>
        <tag>枚举类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day9]]></title>
    <url>%2F2019%2F06%2F06%2Fpython-20190606%2F</url>
    <content type="text"><![CDATA[面向对象高级编程使用__slots__定义class的时候定义一个特殊的__slots__变量，来限制该class实例能添加的属性__slots__定义的属性只对当前类实例起作用，对继承的子类是不起作用的。 12345678910111213141516#给实例绑定一个方法class Student(object): def __init__(self,name): self.name = namedef set_age(self,age): self.age = agefrom types import MethodTypes = Student('Bob')s.set_age = MethodType(set_age,s) #将set_age方法赋给ss.set_age(10)print(s.age)Student.set_age = set_age #将方法赋给类，那么类的所有对象都可以调用该方法s2 = Student('Mary')s2.set_age(20)print(s2.age) 10 20 12345678910111213class Student(object): __slots__ = ('name','age')s = Student()s.age = 10print (s.age)class GStudent(Student): passs1 = GStudent()s1.birth = 1995 #继承的子类没有限制属性，可以绑定birth属性print(s1.birth)s.birth = 1995 #限制的属性里没有birth，报错 10 1995 --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-9-05443cb4292b&gt; in &lt;module&gt; 10 s1.birth = 1995 11 print(s1.birth) ---&gt; 12 s.birth = 1995 #限制的属性里没有birth，报错 AttributeError: &#39;Student&#39; object has no attribute &#39;birth&#39; 使用@property既能检查参数，又可以用类似属性这样简单的方式来访问类的变量。把一个方法变成属性调用。@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。 123456789101112131415class Student(object): @property def score(self): return self.__score @score.setter def score(self,value): if not isinstance(value,int): raise ValueError('score must be an integer') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0~100') self.__score = value s = Student()s.score = 70print(s.score) 70 123456789101112131415161718192021222324252627282930313233#请利用@property给一个Scr.8een对象加上width和height属性，以及一个只读属性resolutionclass Screen(object): @property def width(self): return self.__width @property def height(self): return self.__height @property def resolution(self): return self.__width * self.__height @width.setter def width(self,value): if not isinstance(value,int): raise ValueError('width must be number') self.__width = value @height.setter def height(self,value): if not isinstance(value,int): raise ValueError('height must be number') self.__height = value# 测试:s = Screen()s.width = 1024s.height = 768print('resolution =', s.resolution)if s.resolution == 786432: print('测试通过!')else: print('测试失败!') resolution = 786432 测试通过!]]></content>
      <tags>
        <tag>python</tag>
        <tag>__slots__</tag>
        <tag>\@property</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day8]]></title>
    <url>%2F2019%2F06%2F05%2Fpython-20190605%2F</url>
    <content type="text"><![CDATA[面向对象编程回顾12345678910111213141516171819#请把下面的Student对象的gender字段对外隐藏起来，用get_gender()和set_gender()代替class Student(object): def __init__(self, name, gender): self.name = name self.__gender = gender def get_gender(self): return self.__gender def set_gender(self,gender): self.__gender = gender bart = Student('Bart', 'male')if bart.get_gender() != 'male': print('测试失败!')else: bart.set_gender('female') if bart.get_gender() != 'female': print('测试失败!') else: print('测试成功!') 测试成功! 继承和多态继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。 动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。 1234567891011121314151617181920212223242526#继承与多态class Animals(object): def run(self): print('Animals is running...')class Dogs(Animals): def run(self): print('Dogs is running...')class Cats(Animals): passdog = Dogs()dog.run() #子类的run()覆盖了父类的run()，多态cat = Cats() #子类继承父类的run()，继承cat.run()#鸭子类型class Timer(object): def run(self): print('Start...')def run_twice(x): return x.run()run_twice(Dogs())run_twice(Timer()) #动态语言，只要两个类都有run()方法就可以dir(dog) Dogs is running... Animals is running... Dogs is running... Start... [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;run&#39;] 获取对象信息type()函数，返回对应的class类型，也可以使用该函数的常量判断一个对象是否是函数。 >&gt; type(fn)==types.FunctionTypeTrue>&gt; type(abs)==types.BuiltinFunctionTypeTrue>&gt; type(lambda x: x)==types.LambdaTypeTrue>&gt; type((x for x in range(10)))==types.GeneratorTypeTrue 对于class的继承关系来说，isinstance()函数,可以判断class的类型。 dir()函数，获得一个对象的所有属性和方法，返回一个包含字符串的list。 配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态。 12345678910111213141516print(type(123))print(type('123'))class Myobject(object): def __init__(self): self.x = 9 def power(self): return self.x * self.xobj = Myobject()print(hasattr(obj,'x')) #是否含有这个属性print(getattr(obj,'x')) #获得该属性值setattr(obj,'y','10') #设置一个属性yprint(obj.y) #获取属性yobj2 = Myobject()print(hasattr(obj2,'y')) #obj2没有属性yprint(getattr(obj2,'y',404)) #属性y不存在的话，默认显示404 &lt;class &#39;int&#39;&gt; &lt;class &#39;str&#39;&gt; True 9 10 False 404 实例属性和类属性123456789101112131415161718192021#为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加class Student(object): count = 0 def __init__(self, name): self.name = name Student.count+=1 #每创建一个实例，该属性自动增加# 测试:if Student.count != 0: print('测试失败!')else: bart = Student('Bart') if Student.count != 1: print('测试失败!') else: lisa = Student('Bart') if Student.count != 2: print('测试失败!') else: print('Students:', Student.count) print('测试通过!') 0 Students: 2 测试通过!]]></content>
      <tags>
        <tag>python</tag>
        <tag>继承</tag>
        <tag>多态</tag>
        <tag>鸭子类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day7]]></title>
    <url>%2F2019%2F06%2F04%2Fpython-20190604%2F</url>
    <content type="text"><![CDATA[模块（Module）Python中一个.py文件就称为一个模块。模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。每一个包目录下面都会有一个init.py的文件，这个文件必须存在。Python所有内置函数作用域模块内部使用，通过前缀_实现,最好不要直接引用。（private） 12345678#!/usr/bin/env/ python3#-*- coding:utf-8 -*-def _private(): return '非公开函数'def public(): print('调用非公开函数：') return _private()print(public()) 调用非公开函数： 非公开函数 面向对象编程类和实例类名通常是大写开头的单词，class后面接类名，紧接着是(object)，表示该类是从哪个类继承下来的，通常没有合适的类就用object类，这是所有类最终都会继承的类。特殊方法“__init__”前后分别有两个下划线，第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。 1234567891011121314151617181920212223class Student(object): def __init__(self,name,score,age): self.name = name self.score = score self.__age = age def printScore(self): print('%s :%s'%(self.name,self.score)) def getGrade(self): if self.score&gt;=90: return 'A' elif self.score&gt;=80: return 'B' elif self.score&gt;=60: return 'C' else: return 'D' def getAge(self): return self.__agelisa = Student('Lisa',98,18)lisa.printScore()bart = Student('Bart',80,20)print(bart.getGrade())lisa.getAge() #外部不能直接访问lisa.__age属性了 Lisa :98 B 18 PS:今天有点忙了，就看了一点，😁]]></content>
      <tags>
        <tag>python</tag>
        <tag>类和实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day6]]></title>
    <url>%2F2019%2F06%2F03%2Fpython-20190603%2F</url>
    <content type="text"><![CDATA[高阶函数过滤（filter）filter()函数用于过滤序列，依次作用于每个元素，根据返回值是True或False决定保留还是丢弃该元素。filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。 12345678910111213141516171819202122#用filter求素数def _odd_iter(): #构建一个生成器，无限奇数序列 n = 1 while True: n = n + 2 yield ndef _not_div(n): #定义一个筛选函数 return lambda x : x % n &gt; 0def primes(): #定义一个生成器，不断返回下一个素数 yield 2 it = _odd_iter() #初始序列 while True: n = next(it) yield n it = filter(_not_div(n),it)l=[]for n in primes(): if n &lt; 100: l.append(n) else: breakprint(l) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] 12345678def is_palindrome(n): return n==int(str(n)[::-1]) #判断倒序是否等于正序output = filter(is_palindrome, range(1, 200))print('1~200:', list(output))if list(filter(is_palindrome, range(1, 200))) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]: print('测试成功!')else: print('测试失败!') 1~200: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191] 测试成功! 排序（sorted）内置的sorted函数可以对list进行排序，还可以接受一个key函数来实现自定义的顺序，key指定的函数作用于list的每一个元素上，并根据key函数返回的结果进行排序 123#sortedprint(sorted([3,-234,5,6,23,17],key=abs)) #引用绝对值函数print(sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower,reverse=True)) #reverse 实现反向排序 [3, 5, 6, 17, 23, -234] [&#39;Zoo&#39;, &#39;Credit&#39;, &#39;bob&#39;, &#39;about&#39;] 123456789#按名字排序def by_name(t): return t[0]#按成绩从高到低排序def by_score(t): return -t[1]L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]print(sorted(L,key=by_name))print(sorted(L,key=by_score)) [(&#39;Adam&#39;, 92), (&#39;Bart&#39;, 66), (&#39;Bob&#39;, 75), (&#39;Lisa&#39;, 88)] [(&#39;Adam&#39;, 92), (&#39;Lisa&#39;, 88), (&#39;Bob&#39;, 75), (&#39;Bart&#39;, 66)] 返回函数一个函数可以返回一个计算结果，也可以返回一个函数。返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。 123456789101112def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count()print(f1())print(f2())print(f3()) 9 9 9 12345678910#利用闭包返回一个计数器函数，每次调用它返回递增整数def createCounter(): a=0 def counter(): nonlocal a #使用外层变量 a +=1 return a return countercounterA = createCounter()print(counterA(), counterA(), counterA(), counterA(), counterA()) 1 2 3 4 5 匿名函数关键字lambda表示匿名函数，只能有一个表达式 1234A=list(map(lambda x : x * x,[1,2,3,4,5]))L = list(filter(lambda n : n % 2 == 1, range(1, 20)))print(A)print(L) [1, 4, 9, 16, 25] [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] 装饰器（Decorator）没看懂学习资料里这块的内容🙍，网上查了下，写一点自己对装饰器的理解～装饰器就是可以给任意的函数加点东西，用新的功能包装一下 12345678910#简单版import functoolsdef decorator(fn): #被装饰的函数作为参数传入 print('我是装饰！！！装饰的函数是：%s'%fn.__name__) #作为装饰 return fn@decoratordef fn(): print('这里需要装饰一下。。')fn() 我是装饰！！！装饰的函数是：fn 这里需要装饰一下。。 12345678910111213141516171819202122232425262728#练习，请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间import functools,datetime,timedef log(text): def decorator(fn): @functools.wraps(fn) def wrapper(*args,**kw): #可以接受任意参数的调用,该函数作为装饰 print('执行的函数：%s 执行的时间 ：%s %s'%(fn.__name__,datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),text)) return fn(*args,**kw) return wrapper return decorator@log('测试带参数1～')def fast(x, y): time.sleep(0.0012) return x + y;@log('测试带参数2~')def slow(x, y, z): time.sleep(0.1234) return x * y * z;f = fast(11, 22)print(f)s = slow(11, 22, 33)print(s)if f != 33: print('测试失败!')elif s != 7986: print('测试失败!') 执行的函数：fast 执行的时间 ：2019-06-04 09:36:24 测试带参数1～ 33 执行的函数：slow 执行的时间 ：2019-06-04 09:36:24 测试带参数2~ 7986 偏函数（partial）函数：functools.partial()当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单 12345#偏函数int2=functools.partial(int,base=8) #字符8进制转换print(int2('12345'))max2=functools.partial(max,10) #会把10加入比较print(max2(1,2,3,4)) 5349 10]]></content>
      <tags>
        <tag>python</tag>
        <tag>过滤</tag>
        <tag>排序</tag>
        <tag>lambda</tag>
        <tag>装饰器</tag>
        <tag>偏函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day5]]></title>
    <url>%2F2019%2F05%2F31%2Fpython-20190531%2F</url>
    <content type="text"><![CDATA[列表生成式（List Comprehensions）列表生成式时，把要生成的元素放到前面，后面跟for循环，就可以把list创建出来。 123456print([x*x for x in range(1,11) if x%2 == 0]) #可以加if判断print([m+n for m in 'ABC' for n in 'DEF']) #两层循环d = &#123;'a':'A','b':'B','c':'C'&#125;print([k+'='+v for k,v in d.items()]) #用两个变量生成listL=['MARK','SANDY','SOPHIA']print([s.lower() for s in L]) [4, 16, 36, 64, 100] [&#39;AD&#39;, &#39;AE&#39;, &#39;AF&#39;, &#39;BD&#39;, &#39;BE&#39;, &#39;BF&#39;, &#39;CD&#39;, &#39;CE&#39;, &#39;CF&#39;] [&#39;a=A&#39;, &#39;b=B&#39;, &#39;c=C&#39;] [&#39;mark&#39;, &#39;sandy&#39;, &#39;sophia&#39;] 123#实现列表所有字符串小写L = ['Hello', 'World', 18, 'Apple', None][s.lower() for s in L if isinstance(s,str)] [&#39;hello&#39;, &#39;world&#39;, &#39;apple&#39;] 生成器（generator） 把一个列表生成式的[]改成()，就创建了一个generator。 如果一个函数中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。调用函数就是创建了一个生成器（generator）。yield相当于 return 返回一个值，并且记住这个返回的位置，下次迭代时，代码从yield的下一条语句开始执行 。 抛出StopIteration错误表示无法继续返回下一个值了 12345#生成器g=(x*x for x in range(1,11)) #generater和list的区别是最外层的括号。g是(),list是[]print(next(g))print(next(g))#每次调用next(),是下一个元素的值print([i for i in g]) #利用循环打印所有g的值 1 4 [9, 16, 25, 36, 49, 64, 81, 100] 12345678910def fib(max): n=0 a=0 b=1 while n&lt;max: yield b #定义中包含yield关键字，该函数就是generator a,b=b,a+b n+=1 return 'done'print([i for i in fib(4)]) [1, 1, 2, 3] 1234567891011def odd(): print('step 1') yield 1 print('step 2') yield 2 print('step 3') yield 5o=odd()print(next(o))print(next(o))print(next(o)) step 1 1 step 2 2 step 3 5 1234567891011121314#杨辉三角def triangles(): p = [1] while True: yield p p =[1]+[p[x]+p[x+1] for x in range(len(p)-1)]+[1] #这行看了好久才看懂。。p=[1,3,3,1] x=0,1,2n = 0results = []for t in triangles(): print(t) results.append(t) n = n + 1 if n == 6: break [1] [1, 1] [1, 2, 1] [1, 3, 3, 1] [1, 4, 6, 4, 1] [1, 5, 10, 10, 5, 1] 迭代器（Iterator）可以判断一个对象是否为可迭代对象：isinstance([],Iterable) 12from collections import Iterableisinstance([],Iterable) True 凡是可以作用于for循环的对象都是Iterable类型； 可作用于next()函数的对象都是Iterator类型 集合数据类型如list、dict、str等都是Iterable，不是Iterator，可以通过iter()函数获得一个Iterator对象 函数式编程（Functional Programing）特点：允许把函数本身作为一个参数传入另一个参数，还允许返回一个函数。抽象度高，贴近计算，执行效率低 。Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。 高阶函数函数本身可以赋值给变量，变量可以指向函数。 一个函数可以接受另一个函数做参数，那么这个函数就叫高阶函数。 123456#高阶函数f=absf(-10)def add(x,y,f): return f(x)+f(y)print(add(-1,-6,abs)) 7 map/reducemap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 12345#mapdef f(x): return x*xr=map(f,[1,2,3,4,5])list(r) [1, 4, 9, 16, 25] reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。 12345#reducefrom functools import reduce def add(x,y): return x+yreduce(add,[1,2,3,4,5]) 15 123456789from functools import reducedef str2int(s): def fn(x,y): #输出一个整数 return 10*x+y def char2num(s): #数值与字符对应转换 digits=&#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125; return digits[s] return reduce(fn,map(char2num,s))str2int('1234') 1234 练习 12345678910111213141516171819202122232425#利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']def normalize(l): return l[0].upper()+l[1:].lower()L1 = ['adam', 'LISA', 'barT']L2 = list(map(normalize, L1))print(L2)#请编写一个prod()函数，可以接受一个list并利用reduce()求积def prod(l): def mul(x,y): return x*y return reduce(mul,l)print('3 * 5 * 7 * 9 =', prod([3, 5, 7, 9]))#利用map和reduce编写一个str2float函数，把字符串'123.456'转换成浮点数123.456from functools import reducedef str2float(s): s1,s2 = s.split('.') def fn(x,y): return 10*x+y def char2num(s): digits = &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125; return digits[s] return reduce(fn,map(char2num,s1))+reduce(fn,map(char2num,s2))/(10*len(s2))print(str2float('1234.45')) [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;] 3 * 5 * 7 * 9 = 945 1236.25]]></content>
      <tags>
        <tag>python</tag>
        <tag>列表生成式</tag>
        <tag>生成器</tag>
        <tag>迭代器</tag>
        <tag>map/reduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day4]]></title>
    <url>%2F2019%2F05%2F30%2Fpython-20190530%2F</url>
    <content type="text"><![CDATA[高级特性代码越少越好！越简单越好！ 切片（Slice）根据索引取list或tuple的部分元素list、tuple、字符串都可以使用切片 12345678910#切片L = ['A','B','C','D','E']print(L[0:3]) #从索引0开始，到索引3但不包括索引3M = list(range(20))print(M)print(M[-4:-1]) #倒数第一个元素的索引是-1print(M[:10:2]) #前10个数，每两个取一个print(M[::5]) #所有数，每五个取一个print(len(M))print(M[len(M)-1]) [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] [16, 17, 18] [0, 2, 4, 6, 8] [0, 5, 10, 15] 20 19 1234567891011121314151617181920212223242526272829303132333435363738394041424344#实现一个trim()函数，去除字符串首尾的空格def trim(string): if string[0] == ' ' and string[len(string)-1] == ' ': return string[1:len(string)-1] elif string[0] == ' ': return string[1:] elif string[len(string)-1] == ' ': return string[0:len(string)-1] else: return stringprint(trim(' ABCD '))print(trim(' ABCD'))print(trim('ABCD '))#去掉所有空格def trim2(string): length = len(string) start = -1 end = length - 1 return_str = [] while start &lt; end: start += 1 if string[start] == ' ': continue else: return_str.append(string[start]) #序列转化字符串 return ''.join(return_str)print('原字符串:" A B C DE "') print('去掉所有空格: "%s%s'%(trim2(' A B C DE '),'"'))#去除字符串前后任意多空格def trim3(string): length = len(string) start = 0 end = length - 1 for i in range(length): if string[start] == ' ': start += 1 if string[end] == ' ': end -= 1 if start &gt; end: break return string[start:end+1]print('去除字符串前后任意多空格:"%s%s'%(trim3(' A B C DE '),'"')) ABCD ABCD ABCD 原字符串:&quot; A B C DE &quot; 去掉所有空格: &quot;ABCDE&quot; 去除字符串前后任意多空格:&quot;A B C DE&quot; 迭代（Iteration）给定一个list或者tuple，通过for循环来遍历这个list或tuple，叫做迭代 12345678910#使用迭代查找一个list中最小和最大值，并返回一个tupledef findMinAndMax(L): max=min=None for n in L: if min==None or min&gt;n: min=n if max==None or max&lt;n: max=n return (min,max)print(findMinAndMax([1,2,3,4,5,6])) (1, 6)]]></content>
      <tags>
        <tag>python</tag>
        <tag>切片</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day3]]></title>
    <url>%2F2019%2F05%2F29%2Fpython-20190529%2F</url>
    <content type="text"><![CDATA[函数内置函数 hex() #十六进制转换abs() #求绝对值，一个参数max() #求最大值，多个参数int() #数据类型转整型str() #数据类型转字符float() #数据类型转浮点型isinstance() #数据类型检查函数 python内置函数 定义函数空函数可以用来做占位符，函数体：pass 练习12345678y=input('输入一个数字求绝对值：')z=float(y)def abs_func(x): #def定义函数 if x&gt;=0: return x else: return -xprint(abs_func(z)) 输入一个数字求绝对值：3 3.0 1234from abstest import abs_funcz=input('输入一个数字求绝对值：')y=float(z)print(abs_func(y)) 输入一个数字求绝对值：-3 3.0 可变参数 允许传入0或任意个参数，args,接收的是一个tuple关键字参数 允许传入0或任意个含参数名的参数，kw，接收的是一个dict 命名关键字参数** 限制关键字参数的名字，需要一个特殊分隔符 ，后面的参数被视为命名关键字参数参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数 12345678910#计算坐标import mathdef move(x,y,step,angle=0): nx=x+step*math.cos(angle) ny=y-step*math.sin(angle) return nx,nyx,y=move(100,100,60,math.pi/6)print(x,y)r=move(100,100,60,math.pi/6) #返回tupleprint(r) 151.96152422706632 70.0 (151.96152422706632, 70.0) 123456789101112#求一元二次方程解import mathdef quadratic(a, b, c): m=b*b-4*a*c if m&lt;0: raise Exception('此题无解') n=math.sqrt(m) x1=(-b-n)/2*a x2=(-b+n)/2*a return x1,x2result=quadratic(2,3,1)print(result) (-4.0, -2.0) 123456789#计算x的n次方def power(x,n=2): s=1 while n&gt;0: n=n-1 s=s*x return sprint(power(2,3))print(power(2)) #默认n=2 8 4 12345#kw关键字参数def person(name,age,**kw): print('name',name,'age',age,'other',kw)extract=&#123;'job':'teacher','gender':'M'&#125;person('IVY',20,**extract) name IVY age 20 other {&#39;job&#39;: &#39;teacher&#39;, &#39;gender&#39;: &#39;M&#39;} 123456789101112131415#多个参数相乘def product(*args): if len(args)==0: raise Exception('参数为空') else: s=1 for n in args: s=s*n return sdef product1(x,*y): for i in y: x*=i return xprint(product(1,2,3,4))print(product1(2,3)) 24 6 12345678#递归函数 尾递归，防止栈溢出def fact(n): return fact_iter(n,1)def fact_iter(num,product): if num==1: return product return fact_iter(num-1,num*product)print(fact(5)) 120 123456789#汉诺塔def hanoi(n,a,b,c): #把a柱所有的圆盘移到c柱 if n == 1: print(a,'--&gt;',c) #如果a柱只剩下1个圆盘，移到c柱 else: hanoi(n-1,a,c,b) #剩下的n-1移到b柱 hanoi(1,a,b,c) #a柱剩下的一个圆盘移到c柱 hanoi(n-1,b,a,c) #剩下的n-1从b柱移到c柱hanoi(3,'A','B','C') A --&gt; C A --&gt; B C --&gt; B A --&gt; C B --&gt; A B --&gt; C A --&gt; C]]></content>
      <tags>
        <tag>python</tag>
        <tag>内置函数</tag>
        <tag>参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day2]]></title>
    <url>%2F2019%2F05%2F28%2Fpython-20190528%2F</url>
    <content type="text"><![CDATA[条件判断12345678#条件判断age = 3if age &gt;= 18: print('Adult')elif age&gt;6: print('Teenager')else: print('Kid') Kid 123456s = input('birth is : ')birth = int(s)if birth &lt; 2000: print('00前')else: print('00后') birth is : 1995 00前 12345678910111213141516print('格式 身高：1.75m 体重：80.5kg')a = input('Your height : ')b = input('Your weight : ')height = float(a)weight = float(b)bmi=weight/(height*height)if bmi&gt;32: print('Your BMI is : ',bmi,'严重肥胖')elif bmi&gt;28: print('Your BMI is : ',bmi,'肥胖')elif bmi&gt;25: print('Your BMI is : ',bmi,'过重')elif bmi&gt;18.5: print('Your BMI is : ',bmi,'正常')else: print('Your BMI is : ',bmi,'过轻') 格式 身高：1.75m 体重：80.5kg Your height : 1.75 Your weight : 68 Your BMI is : 22.20408163265306 正常 循环for…in 123names=['A','B','C','D']for name in names: print(name) A B C D 1234sum=0for x in range(101): #整数序列函数 sum=sum+xprint(sum) 5050 while 1234567#whilesum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) 2500 123L = ['Bart', 'Lisa', 'Adam']for x in L: print(x) Bart Lisa Adam 1234567n = 1while n &lt;=100: if n&gt;5: break #提前结束循环 print(n) n=n+1print('end') 1 2 3 4 5 end 123456n=0while n &lt; 10: n=n+1 if n%2==0: continue #跳过这次循环，直接进行到下次 print(n) 1 3 5 7 9 dict内置字典：dict，使用键-值（key-value）存储，具有极快的查找速度和list相比，dict查找的插入速度极快，但是占用大量内存，内存浪费多12345678910#dictd=&#123;'MARY':90, 'JOHN':80, 'ALICE':95&#125;print(d)d['MARY']=80print(d['MARY'])d.pop('ALICE')print(d)print(d.get('ALICE',-1)) {&#39;MARY&#39;: 90, &#39;JOHN&#39;: 80, &#39;ALICE&#39;: 95} 80 {&#39;MARY&#39;: 80, &#39;JOHN&#39;: 80} -1 setset也是一组key的集合，但是不存储value，set中无重复的key。创建一个set，需要提供一个list作为输入集合。 12345678910#sets1=set([1,2,3])print(s)s1.add(4)print(s)s1.remove(4)print(s)s2=set([3,4,5])print(s1&amp;s2)print(s1|s2) {1, 2, 3} {1, 2, 3} {1, 2, 3} {3} {1, 2, 3, 4, 5} 小结：条件判断格式 if:…elif:…else:循环 第一种 while:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种 for…in:循环控制：break，continue 元素可变：list，dict，set元素不可变：tuple]]></content>
      <tags>
        <tag>python</tag>
        <tag>条件判断</tag>
        <tag>循环</tag>
        <tag>dict</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习-Day1]]></title>
    <url>%2F2019%2F05%2F27%2Fpython-20190527%2F</url>
    <content type="text"><![CDATA[首先进行环境安装（Mac）1.python安装 brew install pythonpython -V &nbsp; //版本查看 2.jupyter安装 pip3 install jupyterjupyter notebook &nbsp; //启动服务 环境配置好后，小白开始学习python啦～[python学习资料链接]（https://www.liaoxuefeng.com/wiki/1016959663602400） python基础注释用#标记，转义字符用\标记等号=是赋值语句，可以把任意数据类型赋值给变量，同一变量可以被反复赋值，且可以是不同类型的变量。动态语言。 格式化字符串：% %s 表示用字符串替换； %d 表示用整数替换 %f 表示用浮点数替换 练习>&gt; print(‘hello,%s~ %d day fighting!’%(‘cuify’,1))hello,cuify~ 1 day fighting! list有序列表，可以随时添加和删除其中的元素123456789#listclassmates=['TOM','JACK','MARY']classmates.append('ALICE') #添加元素classmates.insert(1,'JOHN') #插入元素print(classmates)classmates.pop(1) #pop(i) i是索引位置，没写的话会删除最后一个元素print(classmates)classmates[1]='IVY'print(classmates) [&#39;TOM&#39;, &#39;JOHN&#39;, &#39;JACK&#39;, &#39;MARY&#39;, &#39;ALICE&#39;] [&#39;TOM&#39;, &#39;JACK&#39;, &#39;MARY&#39;, &#39;ALICE&#39;] [&#39;TOM&#39;, &#39;IVY&#39;, &#39;MARY&#39;, &#39;ALICE&#39;] 123s=['apple','banana','peach']p=['watermelon',s,'grape'] print(p) [&#39;watermelon&#39;, [&#39;apple&#39;, &#39;banana&#39;, &#39;peach&#39;], &#39;grape&#39;] tuple有序列表，一旦初始化就不能修改。tuple的元素不变指的是tuple的每个元素，指向永不变。 123#tupleclassmates=('TOM','JACK','MARY')print(classmates) (&#39;TOM&#39;, &#39;JACK&#39;, &#39;MARY&#39;) 12345s=('a','b',['X','Y'],'c')print(s)s[2][0]= 'D'print(s)s[1]='r' #元素不可替换 (&#39;a&#39;, &#39;b&#39;, [&#39;X&#39;, &#39;Y&#39;], &#39;c&#39;) (&#39;a&#39;, &#39;b&#39;, [&#39;D&#39;, &#39;Y&#39;], &#39;c&#39;) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-62-e6a11ff7e543&gt; in &lt;module&gt; 3 s[2][0]= &#39;D&#39; 4 print(s) ----&gt; 5 s[1]=&#39;r&#39; TypeError: &#39;tuple&#39; object does not support item assignment]]></content>
      <tags>
        <tag>python</tag>
        <tag>list</tag>
        <tag>tuple</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统工程师软考知识点整理]]></title>
    <url>%2F2019%2F05%2F23%2F%E8%BD%AF%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[数据库系统工程师-软考知识点整理 💯1.音频数字化过程中采样频率应为声音最高频率2倍 2.编译过程：词法分析阶段&gt;语法分析阶段&gt;语义分析阶段&gt;中间代码生成&gt;目标代码生成 3.面向对象方法中的多态：不同类的对象对同一消息做出不同响应。三个条件为有继承关系、子类重写父类方法、父类引用指向子类对象 4.外模式/模式：数据与程序的逻辑独立性，简称数据的逻辑独立性 模式/内模式：数据与程序的物理独立性，简称数据的物理独立性 5.数据模型三要素：数据结构、数据操纵、完整性约束 6.候选码只出现在左边 7.无损连接性判断：存在R1∩R2-&gt;R1-R2或R1∩R2-&gt;R2-R1被F逻辑蕴含的情况，则具有无损连接性无损联接分解是将一个关系模式分解成若干个关系模式后，通过自然联接和投影等运算仍能还原到原来的关系模式，则称这种分解为无损联接分解。 8.满足函数依赖的条件：分解后所有的关系模式加起来和原先的关系模式中的函数依赖是一样的 9.数据库概念结构设计阶段：抽象&gt;设计局部视图&gt;合并取消冲突&gt;修改重构消除冗余 10.路由策略：为了改变网络流量所经过的途径而修改路由信息的技术 11.网络层次与主要设备对应关系： 网络层-路由器，数据链路层-网桥、交换机，传输层和会话层-软件功能 12.I/O设备管理软件一般分4层：中断处理程序、设备驱动程序、与设备无关的系统软件和用户级软件 13.假如关系R和S的元数分别为r和s，那么他们的笛卡儿积就是r+s的元组组合，而若R有m个元组，S有n个元组，则R×S应有m*n个元组 14.脏读：读取未提交数据&emsp;&nbsp;不可重复读：前后多次读取，读取内容不一致&emsp;&nbsp;幻影读：前后多次读取，读取数据总量不一致 15.部分函数依赖：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。举个例子：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。 完全函数依赖：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。举个例子：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB. 传递函数依赖：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。举个例子：通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么成C传递依赖于A 16.三种范式1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项。2、第二范式（2NF）：满足第一范式，然后消除部分依赖。3、第三范式（3NF）： 满足第二范式，消除传递依赖。 17.触发器的定义：某个条件成立的时候，触发器里定义的语句就会被自动的执行。触发器不需要人为的去调用，也不能调用。(1).语句级触发器：可以在某些语句执行前或执行后被触发(2).行级触发器：在定义了触发的表中的行数据改变时就会被触发一次 18.E-R图1.三要素：实体（矩形）、属性（椭圆形）、关系（菱形）2.作为主键的属性在文字下面加下划线3.多值属性 双线椭圆表示；派生属性 虚线椭圆表示；可选属性 椭圆的文字后用(o)表示 19.三类加密算法三类：(1).对称加密：加密和解密使用相同密钥的加密算法。DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES (2).非对称加密：加密和解密使用不同密钥的加密算法，也叫公私钥加密。RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用） (3).Hash算法：Hash算法常用在不可还原的密码存储、信息完整性校验等。MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1 非对称加密算法运行速度慢，可以实现签名；对称加密算法，建议在需要加密大量数据的时候使用，提高加解密速度； 在实际的操作过程中，通常采用的方式是：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。 20.PV操作与信号量的处理有关，P表示通过，V表示释放。用一个信号量与一个消息联系起来，当信号量的值为0时，表示期望的消息尚未产生；当信号量的值非0时，表示期望的消息已经存在。用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。 21.2PL 两段锁协议定义：所有的读写操作之前均需要加锁，解锁操作后不允许出现加锁操作。S锁：加S锁后其他事务可读不可写，直至加锁事务结束；X锁：加X锁后其他事务均不可读或者写，直至事务结束；事务执行分两个阶段：1是获得封锁阶段，2是释放封锁阶段，2PL可能会产生死锁；2PL可以防止丢失修改、读脏数据等；是事务可串行化的必要条件，但不是充分条件； 22.可串行性：当一组事务交叉执行的结果和串行执行的结果一致时，这组事务具有可串行性 23.一级锁：所有写操作前加X锁，事务结束释放，可以防止丢失修改二级锁：所有写操作前加X锁，事务结束释放；读操作前加S锁，操作结束释放，可以防止丢失修改和读脏数据三级锁：所有写操作前加X锁，事务结束释放；读操作前加S锁，事务结束释放，可以防止丢失修改和读脏数据、不可重复读。]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.05.23 ☀️]]></title>
    <url>%2F2019%2F05%2F23%2F20190523%2F</url>
    <content type="text"><![CDATA[离考试还有两天，学习进度达到20%记录，😢]]></content>
      <tags>
        <tag>零零碎碎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.05.16 ☀️]]></title>
    <url>%2F2019%2F05%2F16%2F20190516%2F</url>
    <content type="text"><![CDATA[一些以前写的想法2018.10.25梦会反映现实中捕捉不到的潜意识，负面的、希望的，然而使我略微欣慰的,是我在现实中隐隐意识到了，或许我在主动面对这样自己了。 2018.11.06突然就会很想感谢生命中的贵人，感谢他们在我人生中每一个微不足道的节骨眼助了力。 2018.11.12生日周的第一天变得很亢奋，一下不能理解原来的负面情绪都是从哪来的了。 2019.2.15今天开始准备数据库系统工程师的考试，希望能坚持下去，要把大学的专业课重新看一遍，脑壳痛。脑子饱了，肚子瘪了。]]></content>
      <tags>
        <tag>零零碎碎</tag>
      </tags>
  </entry>
</search>
